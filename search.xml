<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS内存空间</title>
    <url>/2020/12/01/JS%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<blockquote>
<p>一步一步重温 <strong>JavaScript</strong> 基础系列。<br>本章节将会理解JS的内存空间、垃圾回收机制、内存泄漏以及如何分析定位内存泄漏</p>
</blockquote>
<h2 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h2><a id="more"></a>
<h3 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h3><ul>
<li><strong>栈内存</strong>，结构特点是后进先出（LIFO）</li>
<li><strong>堆内存</strong>，结构类似于书架，通过 key-value 的形式读取</li>
</ul>
<h3 id="变量的存放"><a href="#变量的存放" class="headerlink" title="变量的存放"></a>变量的存放</h3><ul>
<li><strong>基本类型</strong>，保存在栈内存中，占据内存空间大小固定，通过按值来访问</li>
<li><strong>引用类型</strong>，其值大小不固定，保存在堆内存中，但其引用大小固定，保存在栈内存中。当查询引用类型的变量时，先从栈中读取内存地址，然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问</li>
</ul>
<p>可以通过复制变量的值来理解如下：</p>
<p><img src="/images/复制变量值.jpg" alt="复制变量的值图解"></p>
<h2 id="内存空间管理"><a href="#内存空间管理" class="headerlink" title="内存空间管理"></a>内存空间管理</h2><h3 id="内存空间生命周期"><a href="#内存空间生命周期" class="headerlink" title="内存空间生命周期"></a>内存空间生命周期</h3><ul>
<li>分配所需的内存</li>
<li>使用分配的内存（读、写）</li>
<li>不需要时将其释放</li>
</ul>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>JS有自动垃圾收集机制GC(Garbage collection)，因为开销较大，GC并非实时进行，而是定时周期性执行。所以，通过将变量赋值为null等方法将变量从当前执行环境释放时，并不会被立即回收清除。<br>在局部作用域中，当函数执行完毕后，执行栈就会将其推出，内部变量很容易被标记并回收。但是全局作用域以及闭包内的变量，什么时候释放回收，JS引擎很难判断，因此，在实际开发中，应尽量减少使用全局变量和闭包。</p>
<ul>
<li><p>回收方式一：<strong>标记清除</strong></p>
<ul>
<li>当变量进入执行环境时，标记为“进入环境”，离开执行环境时，标记为“离开”；</li>
<li>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）；</li>
<li>然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）；</li>
<li>而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了；</li>
<li>最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</li>
</ul>
</li>
<li><p>回收方式二：<strong>引用计数</strong></p>
<ul>
<li>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</li>
</ul>
</li>
</ul>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p><strong>内存溢出</strong>，是指程序运行所需要的内存，超过剩余内存，常见如递归死循环等<br><strong>内存泄漏</strong>，是指不再用到的内存，没有及时释放。</p>
<h3 id="引起内存泄漏的几种情况"><a href="#引起内存泄漏的几种情况" class="headerlink" title="引起内存泄漏的几种情况"></a>引起内存泄漏的几种情况</h3><ul>
<li><p><strong>DOM元素的不恰当处理</strong></p>
<ul>
<li>原因：DOM元素被删除，但是仍然有变量引用该DOM，导致GC无法回收该变量</li>
<li>解决：DOM元素被删除时，将引用该DOM的变量，赋值为null，解除引用，待GC回收清除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 声明一个变量，保存DOM元素video</span><br><span class="line">var video = document.getElmentById(&apos;#video&apos;);</span><br><span class="line"></span><br><span class="line">// 将video从body中移除</span><br><span class="line">document.querySelector(&apos;body&apos;).removeChild(video);</span><br><span class="line"></span><br><span class="line">console.log(video);</span><br><span class="line">// 打印结果仍然为DOM元素video</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>意外的全局变量</strong></p>
<ul>
<li>原因：在函数作用域内，忘记使用var声明变量，或者是在this上新增属性，导致意外创建一个全局变量</li>
<li>解决：使用严格模式 ‘use strict’，避免此类错误发生</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo () &#123;</span><br><span class="line">  // 忘记使用var声明变量，此时name成为全局变量</span><br><span class="line">  name = &apos;xug&apos;;</span><br><span class="line"></span><br><span class="line">  // 在this上新增age属性，由于foo由全局调用，此时this指向全局作用域window，故age成为全局作用域</span><br><span class="line">  this.age = 32;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">// 如以上所示，即便foo被GC回收，name和age也不会被回收，由此造成内存泄漏</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>被遗忘的计时器或回调函数</strong></p>
<ul>
<li>原因：setInterval()和 setTimeout()在使用完之后如果没有手动清除，会一直存在执行，占用内存</li>
<li>解决：定时器手动清除，且将引用定时器的变量值置为null<br>例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// setInterval</span><br><span class="line">var timer1 = setInterval(function()&#123;</span><br><span class="line">  console.log(&apos;111&apos;)</span><br><span class="line">&#125;,1000)</span><br><span class="line"></span><br><span class="line">clearInterval(timer1)</span><br><span class="line">timer1 = null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// setTimeout</span><br><span class="line">var timer2 = setTimeout(function()&#123;</span><br><span class="line">  console.log(&apos;222&apos;)</span><br><span class="line">&#125;,1000)</span><br><span class="line"></span><br><span class="line">clearTimeout(timer2)</span><br><span class="line">timer2 = null</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>闭包</strong></p>
<ul>
<li>原因：形成闭包后，内层函数会引用外层函数的变量，这样导致JS引擎无法回收此变量</li>
<li>解决：解除对匿名函数的引用<br>例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn () &#123;</span><br><span class="line">  var num = 3;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var n = 0;</span><br><span class="line">    console.log(++n);</span><br><span class="line">    console.log(++num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn1 = fn();</span><br><span class="line">fn1() // 1 4</span><br><span class="line">fn1() // 1 5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>一般情况下，在函数fn执行完后，就应该连同它里面的变量一同被销毁，但是在这个例子中，匿名函数作为fn的返回值被赋值给了fn1，并且匿名函数内部引用着fn里的变量num，所以变量num无法被GC回收，由此产生内存泄漏。而变量n是每次被调用时新创建的，所以每次fn1执行完后它就把属于自己的变量连同自己一起销毁。</p>
<p>只需将 fn1 = null， 即可释放对匿名函数的引用</p>
</li>
</ul>
<h3 id="如何分析内存泄漏"><a href="#如何分析内存泄漏" class="headerlink" title="如何分析内存泄漏"></a>如何分析内存泄漏</h3><ul>
<li><p><strong>window.performance.memory</strong> 输出当前内存属性</p>
<ul>
<li>jsHeapSizeLimit: 内存大小限制</li>
<li>totalJSHeapSize: 可使用的内存</li>
<li>usedJSHeapSize:  JS对象(包括V8引擎内部对象)已占用的内存<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.performance.memory</span><br><span class="line">MemoryInfo &#123;</span><br><span class="line">  jsHeapSizeLimit: 4294705152,</span><br><span class="line">  totalJSHeapSize: 101622250,</span><br><span class="line">  usedJSHeapSize: 86986030</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Chrome浏览器，录制 Performance-memory 查看各项指标变化</p>
<ul>
<li>JS Heap: 应用的内存占用量</li>
<li>Documents: 当前页面中使用的样式或者脚本文件数目</li>
<li>Nodes: 内存中 DOM 节点数目</li>
<li>Listeners: 当前页面上注册的 JavaScript 事件监听器数量<br>如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。反之，则存在内存泄漏。</li>
</ul>
</li>
<li><p>利用node命令行：<strong>process.memoryUsage()</strong>， 输出内存使用情况</p>
<ul>
<li>rss（resident set size）：所有内存占用，包括指令区和堆栈。</li>
<li>heapTotal：”堆”占用的内存，包括用到的和没用到的。</li>
<li>heapUsed：用到的堆的部分。</li>
<li>external： V8 引擎内部的 C++ 对象占用的内存</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中 export default 和 export 区别</title>
    <url>/2017/12/08/ES6-export-default-%E5%92%8C-export-%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>es6渐入主流，export default 和 export经常使用，但是偶尔也会采坑，难得今天公司网络故障，没法做事，正好可以写点心得，避免后面遗忘。</p>
</blockquote>
<ul>
<li>export：使用命名导出</li>
<li>export default：使用默认导出</li>
</ul>
<a id="more"></a>
<h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul>
<li>1、 export 与 export default 均可用于导出常量、函数、文件、模块等；</li>
<li>2、均可以在其他模块和文件使用import的方式进行导入使用；</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>1、通过export方式导出，在导入时需以对象方式进行导入，即加上{xxx}，但是export default不需要；</li>
<li>2、 在一个导出文件或模块中，export可以有很多个，但是export default 只能有一个。</li>
<li>3、 使用export default进行导出，导入时可以使用任意变量名称</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.使用<span class="built_in">export</span>导出</span><br><span class="line"></span><br><span class="line">①方式一</span><br><span class="line">// utils.js 导出文件</span><br><span class="line"><span class="built_in">export</span> const setCookie = (name, value, time) =&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> days = time || 7;    // 默认保存7天</span><br><span class="line">    <span class="built_in">let</span> exp = new Date();</span><br><span class="line">    const PATH = location.pathname.split(<span class="string">'/'</span>)[1];</span><br><span class="line">    <span class="built_in">let</span> _path = (PATH.length == 0 || PATH.indexOf(<span class="string">'.'</span>) != -1) ? <span class="string">'/'</span> : PATH;</span><br><span class="line">    exp.setTime(exp.getTime() + days * 24 * 60 * 60 * 1000);</span><br><span class="line">    document.cookie = `<span class="variable">$&#123;name&#125;</span>=<span class="variable">$&#123;escape(value)&#125;</span>;path=<span class="variable">$&#123;_path&#125;</span>;expires=<span class="variable">$&#123;exp.toGMTString()&#125;</span>`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> getCookie(name)&#123;</span><br><span class="line">    <span class="built_in">let</span> arr, reg = new RegExp(<span class="string">"(^| )"</span> + name + <span class="string">"=([^;]*)(;|$)"</span>)</span><br><span class="line">    <span class="keyword">if</span> (arr = document.cookie.match(reg))</span><br><span class="line">        <span class="built_in">return</span> unescape(arr[2]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//b.js 导入文件</span><br><span class="line">import &#123; setCookie, getCookie &#125; from <span class="string">'./utils'</span>; //也可以分开写两次，导入的时候带花括号</span><br><span class="line"></span><br><span class="line">②方式二</span><br><span class="line">// foo.js 导出文件</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> foo2(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> x * x * x;</span><br><span class="line">&#125;</span><br><span class="line">const foo2 = Math.floor(Math.random()*9 + 3);</span><br><span class="line"><span class="built_in">export</span> &#123; foo1,foo2 &#125;;</span><br><span class="line"></span><br><span class="line">// use.js 导入文件</span><br><span class="line">import &#123; foo1, foo2 &#125; from <span class="string">'foo.js'</span>;</span><br><span class="line">console.log(foo1(3)); // 27</span><br><span class="line">console.log(foo2);    // 3-12之间随机数</span><br><span class="line"></span><br><span class="line">2.使用<span class="built_in">export</span> default导出</span><br><span class="line">// utils.js</span><br><span class="line">const unique = (a) =&gt; &#123;</span><br><span class="line">    var <span class="built_in">hash</span> = &#123;&#125;,</span><br><span class="line">        len = a.length,</span><br><span class="line">        arr = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">hash</span>[a[i]]) &#123;</span><br><span class="line">            <span class="built_in">hash</span>[a[i]] = <span class="literal">true</span>;</span><br><span class="line">            arr.push(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default unique;</span><br><span class="line"></span><br><span class="line">//b.js 导入文件</span><br><span class="line">import unique from <span class="string">'./utils'</span>; //注意，导入的时候没有花括号</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 数组去重</title>
    <url>/2018/02/06/JS-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<ul>
<li><p>1、 数组元素为基本数据类型</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const unique = (arrwy) =&gt; &#123;</span><br><span class="line">       <span class="built_in">let</span> obj = &#123;&#125;, arr = [];</span><br><span class="line">    arrwy.forEach((ele, index) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj[ele])&#123;</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            obj[ele] = <span class="string">'1'</span>;</span><br><span class="line">            arr.push(ele)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <a id="more"></a>
<p>  原理：new一个空对象和一个空数组，遍历原数组，将原数组每一项作为空对象的新增属性，循环过程中，如果目标对象已经包含该属性，则return，否则给该属性取值为1，并把该属性push进空数组。此空数组即为原数组去重后的数组。</p>
</li>
<li><p>2、 数组元素为基本数据类型（es6 Set）</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[...new Set([1,<span class="string">'1'</span>,<span class="string">'1'</span>,2,1])]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>3、 数组元素为对象，且去重标准为其中的某一个属性</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	const unique = (arrwy,key) =&gt; &#123;</span><br><span class="line">	    <span class="built_in">let</span> obj = &#123;&#125;, arr = [];</span><br><span class="line">	    arrwy.forEach((ele, index) =&gt; &#123;</span><br><span class="line">	        <span class="keyword">if</span>(obj[ele.key])&#123;</span><br><span class="line">	            <span class="built_in">return</span></span><br><span class="line">	        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	            obj[ele.key] = <span class="string">'1'</span>;</span><br><span class="line">	            arr.push(ele)</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;);</span><br><span class="line">	    <span class="built_in">return</span> arr;</span><br><span class="line">	&#125;</span><br><span class="line">	```	</span><br><span class="line">	</span><br><span class="line">	原理：new一个空对象和一个空数组，遍历原数组，将原数组每一项的指定属性的属性值作为空对象的新增属性，循环过程中，如果目标对象已经包含该属性，则<span class="built_in">return</span>，否则给该属性取值为1，并把该属性push进空数组。此空数组即为原数组去重后的数组。</span><br><span class="line">	</span><br><span class="line">* 4、 数组元素为对象，且去重标准为其中的某几个属性</span><br><span class="line"></span><br><span class="line">	``` bash</span><br><span class="line">		//将对象元素转换成字符串以作比较  </span><br><span class="line">		<span class="keyword">function</span> obj2key(obj, keys)&#123;  </span><br><span class="line">		    var n = keys.length,  </span><br><span class="line">		        key = [];  </span><br><span class="line">		    <span class="keyword">while</span>(n--)&#123;  </span><br><span class="line">		        key.push(obj[keys[n]]);  </span><br><span class="line">		    &#125;  </span><br><span class="line">		    <span class="built_in">return</span> key.join(<span class="string">'|'</span>);  </span><br><span class="line">		&#125;  </span><br><span class="line">		</span><br><span class="line">		//去重操作  </span><br><span class="line">		<span class="keyword">function</span> uniqeByKeys(array,keys)&#123;  </span><br><span class="line">		    var arr = [];  </span><br><span class="line">		    var <span class="built_in">hash</span> = &#123;&#125;;  </span><br><span class="line">		    <span class="keyword">for</span> (var i = 0, j = array.length; i &lt; j; i++) &#123;  </span><br><span class="line">		        var k = obj2key(array[i], keys);  </span><br><span class="line">		        <span class="keyword">if</span> (!(k <span class="keyword">in</span> <span class="built_in">hash</span>)) &#123;  </span><br><span class="line">		            <span class="built_in">hash</span>[k] = <span class="literal">true</span>;  </span><br><span class="line">		            arr .push(array[i]);  </span><br><span class="line">		        &#125;  </span><br><span class="line">		    &#125;  </span><br><span class="line">		    <span class="built_in">return</span> arr ;  </span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="built_in">let</span> arr = [&#123;</span><br><span class="line">			name: <span class="string">'aaa'</span>,</span><br><span class="line">			<span class="built_in">type</span>: <span class="string">'shop'</span></span><br><span class="line">		&#125;,&#123;</span><br><span class="line">			name: <span class="string">'bbb'</span>,</span><br><span class="line">			<span class="built_in">type</span>: <span class="string">'msg'</span></span><br><span class="line">		&#125;,&#123;</span><br><span class="line">			name: <span class="string">'bbb'</span>,</span><br><span class="line">			<span class="built_in">type</span>: <span class="string">'msg'</span></span><br><span class="line">		&#125;];</span><br><span class="line">		arr = uniqeByKeys(arr,[<span class="string">'name'</span>,<span class="string">'type'</span>]);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数据类型</title>
    <url>/2020/11/22/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>一步一步重温 <strong>JavaScript</strong> 基础系列。<br>本章节将会理解JS的数据类型，以及如何检测JS数据类型。</p>
</blockquote>
<h2 id="1-JavaScript-数据类型"><a href="#1-JavaScript-数据类型" class="headerlink" title="1 JavaScript 数据类型"></a>1 JavaScript 数据类型</h2><ul>
<li>六种基本数据类型：Null、Undefined、Boolean、Number、String 和 Symbol（es6）</li>
<li>一种引用数据类型：Object</li>
</ul>
<a id="more"></a>
<h3 id="1-1-Null-和-Undefined-区别"><a href="#1-1-Null-和-Undefined-区别" class="headerlink" title="1.1 Null 和 Undefined 区别"></a>1.1 Null 和 Undefined 区别</h3><ul>
<li>Null 是指变量未声明， 或者声明但未赋值</li>
<li>Undefined 是指变量声明且赋值为空</li>
</ul>
<p>一般会在以下两种情况下，将变量赋值为null:</p>
<ol>
<li>当一个变量准备用来存放一个对象，一开始又没有存放时，可以先赋值为null</li>
<li>解除引用，比如释放定时器等（注：解除一个值的引用并不意味着自动回收该值所占用的内存，让变量脱离执行环境，以便垃圾收集器在下次运行时将其回收）</li>
</ol>
<h3 id="1-2-Symbol"><a href="#1-2-Symbol" class="headerlink" title="1.2 Symbol"></a>1.2 Symbol</h3><p>一种类似于字符串的数据类型，表示独一无二的值，用来防止属性名的冲突</p>
<h2 id="3-检测数据类型"><a href="#3-检测数据类型" class="headerlink" title="3 检测数据类型"></a>3 检测数据类型</h2><p>① typeof 返回该种数据类型的字符串形式，如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof 1          // &quot;number&quot;</span><br><span class="line">typeof(typeof 1)  // &quot;string&quot;</span><br><span class="line">  </span><br><span class="line">typeof null       // &quot;object&quot;, null表示一个空对象指针，故返回&quot;object&quot;</span><br><span class="line">typeof foo        // &quot;function&quot;, function也是对象，理论上应返回&quot;object&quot;, 但是函数有其特殊属性，有必要进行区分，故返回 &quot;function&quot;</span><br></pre></td></tr></table></figure>
<p>  <code>typeof</code> 只能用来检测除 <code>null</code> 类型外的其它基本类型，另外能够检测出引用类型中 <code>function</code> 数据类型。</p>
<p>② instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上， 如下：<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function A () &#123;&#125;</span><br><span class="line">function B () &#123;&#125;</span><br><span class="line"></span><br><span class="line">var a = new A()</span><br><span class="line">var B = new B()</span><br><span class="line"></span><br><span class="line">a instanceof A    // true, 因为Object.getPrototypeOf(a).__proto__ === A.prototype</span><br><span class="line">a instanceof B    // false</span><br></pre></td></tr></table></figure></p>
<p>  <code>instanceof</code>只能够检测出引用类型的变量，是否在右侧构造函数的原型链上，并且由于所有引用类型都是Object的实例，所以在检测一个引用类型的变量 和 Object构造函数时，instanceof操作符始终会返回true。</p>
<p>③ Object.prototype.toString， 能够检测出所有的数据类型， 如下：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.prototype.toString.call(1)    // &quot;[object Number]&quot;</span><br><span class="line">Object.prototype.toString.call(&apos;1&apos;)  // &quot;[object String]&quot;</span><br><span class="line">Object.prototype.toString.call(null) // &quot;[object Null]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)   // &quot;[object Object]&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>综上所述，JS检测数据，最优方法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @desc   数据类型检测</span><br><span class="line"> * @params val &#123; any &#125; 待检测的数据</span><br><span class="line"> * @return &#123; String &#125; 类型字符串 </span><br><span class="line"> */</span><br><span class="line">function type(val) &#123;     </span><br><span class="line">	return typeof val !== &quot;object&quot; </span><br><span class="line">		? typeof val </span><br><span class="line">		: Object.prototype.toString.call(val).slice(8, -1).toLowerCase(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript执行环境及作用域</title>
    <url>/2020/11/25/Javascript%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<blockquote>
<p>一步一步重温 <strong>JavaScript</strong> 基础系列。<br>本章节将会理解JS的执行环境即执行上下文相关概念，包括变量对象、活动对象、以及两者区别</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>执行环境</strong>（execution context）定义了变量或函数有权访问的其它数据，决定了各自的行为。当JS代码执行的时候，会进入不同的执行环境，这些不同的执行环境就构成了执行环境栈。当执行环境中的代码执行完毕之后，执行环境被销毁，其中的所有变量和函数也随之销毁。执行环境也称之为执行上下文。</p>
<a id="more"></a>
<p>每个执行环境都有三个重要的属性：变量对象（VO）、作用域链（scope chain）以及 this。</p>
<p><img src="/images/执行环境01.jpg" alt="按值传递图解"><br>注：对于VO来说，函数表达式不包含在VO中，没有使用var声明的变量也不包含在VO中，这种方式只是给Global添加了一个属性。</p>
<h2 id="执行上下文类型"><a href="#执行上下文类型" class="headerlink" title="执行上下文类型"></a>执行上下文类型</h2><ul>
<li><strong>全局执行上下文</strong>，只有一个，在浏览器中，通常为windows对象，所有的全局变量和函数都作为window对象的属性和方法存在。对于全局执行环境来说，当关闭网页或浏览器时，该环境被销毁；</li>
<li><strong>局部（函数）执行上下文</strong> ，每个函数都有自己的执行环境，当js执行流进入一个函数时，函数的环境会被推入一个环境栈中，当函数执行完毕后，栈将其环境弹出，该环境随即被销毁；</li>
<li><strong>Eval上下文</strong>，运行在 eval 函数中的代码，由于eval 的性能低、不易调试且有安全问题，一般禁止使用。 </li>
</ul>
<h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也称调用栈，具有“后进先出”（LIFO）原则，用于储存代码的执行期间创建的所有执行上下文。</p>
<p>首次运行js代码时，会创建一个全局执行上下文，并被push至执行栈首位。当顺序执行函数调用时，引擎都会为执行函数创建一个执行上下文，并push至当前执行栈的栈顶。</p>
<p>当函数调用完成后，其执行上下文就会从执行栈顶被推出（这是理想情况，闭包则不会，后续深入理解）。</p>
<h2 id="执行上下文的生命周期"><a href="#执行上下文的生命周期" class="headerlink" title="执行上下文的生命周期"></a>执行上下文的生命周期</h2><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><ul>
<li>创建变量环境（VO）<br>  ① 函数环境会初始化创建 Arguments对象（并赋值）<br>  ② 函数声明（并赋值）<br>  ③ 变量声明，函数表达式声明（未赋值）</li>
<li>确定this指向（this由调用者确定）</li>
<li>确定作用域（词法环境决定，哪里声明定义，就在哪里确定）</li>
</ul>
<h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><ul>
<li>变量对象赋值<br>  ① 变量赋值<br>  ② 函数表达式赋值</li>
<li>调用函数</li>
<li>顺序执行其它代码</li>
</ul>
<p>代码解释如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 第一步： </span><br><span class="line"> * 当程序加载时全局执行环境就被创建，并且创建一个VO对象来保存当前全局变量与全局函数，</span><br><span class="line"> * 在刚刚创建的VO对象中，变量的值被保存为undefined，函数属性的值保存为对应的函数体 </span><br><span class="line"> * 全局执行环境 ==&gt; VO = &#123;</span><br><span class="line"> 		a: undefined,</span><br><span class="line"> 		fn1: fn1函数体,</span><br><span class="line"> 		fn3: fn3函数体</span><br><span class="line">	&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">var a = &quot;global&quot;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 第二步： </span><br><span class="line"> * 当程序执行到此处时，变量a执行赋值操作，VO对象中的属性a的值发生变化</span><br><span class="line"> * 全局执行环境 ==&gt; VO = &#123;</span><br><span class="line"> 		a: &quot;global&quot;,</span><br><span class="line"> 		fn1: fn1函数体,</span><br><span class="line"> 		fn3: fn3函数体</span><br><span class="line">	&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">function fn3(num)&#123;</span><br><span class="line">   console.log(num);  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function fn1(num1,num2)&#123;</span><br><span class="line">	var b = num1 + num2;</span><br><span class="line"></span><br><span class="line">	function fn2(num3)&#123;</span><br><span class="line">		var c = ++num3;</span><br><span class="line">		fn3(c);</span><br><span class="line">		/*第五步*/</span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	fn2(b);</span><br><span class="line">	/*第四步*/</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fn1(2,5);</span><br><span class="line">/*</span><br><span class="line"> * 第三步： </span><br><span class="line"> * 发现fn1函数被调用并传参，那么就进入fn1函数内部并创建fn1执行环境，由于在函数执行环境中</span><br><span class="line"> * VO是无法直接访问的，所以当fn1环境被创建时，会同时创建一个AO对象，其默认带有一个arg属性</span><br><span class="line"> * 这个属性保存了函数调用时传入的实参，该AO对象同时也会保存fn1函数的形参num1,num2并赋值，</span><br><span class="line"> * 保存局部变量b，b的值为undefined， 函数属性的值保存为对应的函数体 </span><br><span class="line"> * fn1执行环境 ==&gt; AO = &#123;</span><br><span class="line"> 		arguments: [2,5],</span><br><span class="line"> 		num1: 2, </span><br><span class="line"> 		num2: 5, </span><br><span class="line"> 		b= undefined,</span><br><span class="line"> 		fn2: fn2函数体</span><br><span class="line">	&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<p><strong>总结</strong>：<br>① 当程序开始执行，自动创建一个全局执行环境和一个VO对象；<br>② 当函数被调用时，在函数中会创建一个函数执行环境和一个AO对象，AO与VO功能相同；<br>③ 当函数执行环境被创建后，js会创建一个执行环境栈，将当前执行环境入栈，当该函数执行结束之后，其对应的执行环境会从栈中抛出并销毁。</p>
<h2 id="变量对象（AO）和活动对象（VO）"><a href="#变量对象（AO）和活动对象（VO）" class="headerlink" title="变量对象（AO）和活动对象（VO）"></a>变量对象（AO）和活动对象（VO）</h2><h3 id="变量对象（Variable-Object，简称VO）"><a href="#变量对象（Variable-Object，简称VO）" class="headerlink" title="变量对象（Variable Object，简称VO）"></a>变量对象（Variable Object，简称VO）</h3><p>每个执行环境都有一个与之关联的变量对象，用来保存环境中定义的所有变量和函数。一般来说，VO对象包含变量、形参和函数声明。</p>
<h3 id="活动对象（Activation-Object，简称AO）"><a href="#活动对象（Activation-Object，简称AO）" class="headerlink" title="活动对象（Activation Object，简称AO）"></a>活动对象（Activation Object，简称AO）</h3><p>当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象(AO)，这时候活动对象上的各种属性才能被访问。</p>
<p>函数的执行环境是在调用时创建的，在创建函数执行环境的同时会对应创建一个带有arguments属性的AO对象，该对象将代替VO对象来保存当前函数环境中的变量、参数和函数，所以在函数执行环境中VO就是AO。</p>
<h3 id="VO和AO的区别"><a href="#VO和AO的区别" class="headerlink" title="VO和AO的区别"></a>VO和AO的区别</h3><p>① 非函数执行环境对应创建一个VO对象；<br>② 函数执行环境对应创建一个默认带有arguments属性的AO对象；<br>③ AO是函数执行环境下的VO，两者的作用是相同的。</p>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>css使用技巧（1）-元素居中</title>
    <url>/2018/02/08/css%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%881%EF%BC%89-%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<p>css元素居中是个永恒的话题，随着前端技术的进一步发展，实现方式也是愈来愈多，这里讲几个实用且高效的方式：</p>
<h3 id="1、-水平居中"><a href="#1、-水平居中" class="headerlink" title="1、 水平居中"></a>1、 水平居中</h3><ul>
<li><p>1、 行内（内联）元素： text-align: center;</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>2、 块级元素：margin: xpx auto; （子元素需设置宽度）</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.child&#123;</span><br><span class="line">	width: 200px;</span><br><span class="line">	margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>3、 flex布局： 子元素为内联元素</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	.parent&#123;</span><br><span class="line">		display: flex;</span><br><span class="line">		justify-content: center;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	```	</span><br><span class="line">	</span><br><span class="line">* 4、 flex布局： 子元素为块级元素（子元素无需设置宽度）</span><br><span class="line"></span><br><span class="line">	``` bash</span><br><span class="line">	</span><br><span class="line">	.parent&#123;</span><br><span class="line">		display: flex;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.child&#123;</span><br><span class="line">		margin: 10px auto;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	```		</span><br><span class="line">	</span><br><span class="line"><span class="comment">### 2、 垂直居中</span></span><br><span class="line">	</span><br><span class="line">* 1、 行内（内联）元素： height = line-height</span><br><span class="line"></span><br><span class="line">	``` bash</span><br><span class="line">	</span><br><span class="line">	.parent&#123;</span><br><span class="line">		height: 200px;</span><br><span class="line">		line-height: 200px;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>2、 块级元素: 绝对定位（子元素尺寸需确定, margin负值实现位移）    </p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.parent&#123;</span><br><span class="line">	position: relative;</span><br><span class="line">	height: 300px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.child&#123;</span><br><span class="line">	width: 50px;</span><br><span class="line">	height: 40px;</span><br><span class="line">	position: absolute;</span><br><span class="line">	left: 50%;</span><br><span class="line">	right: 50%;</span><br><span class="line">	margin-top: -20px;</span><br><span class="line">	margin-right: -25px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、 块级元素: 绝对定位（子元素尺寸需确定, margin: auto）    </p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	.parent&#123;</span><br><span class="line">		position: relative;</span><br><span class="line">		height: 300px;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.child&#123;</span><br><span class="line">		width: 50px;</span><br><span class="line">		height: 50px;</span><br><span class="line">		position: absolute;</span><br><span class="line">		top: 0;</span><br><span class="line">		right: 0;</span><br><span class="line">		bottom: 0;</span><br><span class="line">		left: 0;</span><br><span class="line">		margin: auto;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	```		</span><br><span class="line">	</span><br><span class="line">* 4、 块级元素: 绝对定位（子元素尺寸无需确定, transform位移）	</span><br><span class="line"></span><br><span class="line">	``` bash</span><br><span class="line">	</span><br><span class="line">	.parent&#123;</span><br><span class="line">		position: relative;</span><br><span class="line">		height: 300px;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.child&#123;</span><br><span class="line">		position: absolute;</span><br><span class="line">		left: 50%;</span><br><span class="line">		right: 50%;</span><br><span class="line">		transform: translate(-50%,-50%);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>5、 flex布局，子元素为块级元素，父元素display: flex; 子元素margin: auto;</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	.parent&#123;</span><br><span class="line">		display: flex;</span><br><span class="line">		width: 500px;</span><br><span class="line">		height: 500px;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.child&#123;</span><br><span class="line">		margin: auto 10px;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	```	</span><br><span class="line">	</span><br><span class="line">* 6、 flex布局, 子元素为内联元素，父级元素display: flex; </span><br><span class="line"></span><br><span class="line">	``` bash</span><br><span class="line">	</span><br><span class="line">	.parent&#123;</span><br><span class="line">		display: flex;</span><br><span class="line">		width: 500px;</span><br><span class="line">		height: 500px;</span><br><span class="line">		align-items: center;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>git 常用操作</title>
    <url>/2017/12/13/git-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="一、提交代码"><a href="#一、提交代码" class="headerlink" title="一、提交代码"></a>一、提交代码</h3><h5 id="查看当前目录下更改的文件"><a href="#查看当前目录下更改的文件" class="headerlink" title="查看当前目录下更改的文件"></a>查看当前目录下更改的文件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="查看当前目录下更改文件的更改点"><a href="#查看当前目录下更改文件的更改点" class="headerlink" title="查看当前目录下更改文件的更改点"></a>查看当前目录下更改文件的更改点</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>
<h5 id="添加当前目录下的所有文件到暂存区"><a href="#添加当前目录下的所有文件到暂存区" class="headerlink" title="添加当前目录下的所有文件到暂存区"></a>添加当前目录下的所有文件到暂存区</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<h5 id="将代码从暂存区提交至仓库区"><a href="#将代码从暂存区提交至仓库区" class="headerlink" title="将代码从暂存区提交至仓库区"></a>将代码从暂存区提交至仓库区</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"描述"</span></span><br></pre></td></tr></table></figure>
<h5 id="将远程仓库区代码同步本地"><a href="#将远程仓库区代码同步本地" class="headerlink" title="将远程仓库区代码同步本地"></a>将远程仓库区代码同步本地</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull    或者 git pull origin 远程仓库名</span><br></pre></td></tr></table></figure>
<h5 id="将本地仓库区代码提交至远程仓库"><a href="#将本地仓库区代码提交至远程仓库" class="headerlink" title="将本地仓库区代码提交至远程仓库"></a>将本地仓库区代码提交至远程仓库</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin 远程仓库名    或者 git push</span><br></pre></td></tr></table></figure>
<h3 id="二、撤销操作"><a href="#二、撤销操作" class="headerlink" title="二、撤销操作"></a>二、撤销操作</h3><h5 id="撤销add操作"><a href="#撤销add操作" class="headerlink" title="撤销add操作"></a>撤销add操作</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD .</span><br></pre></td></tr></table></figure>
<h5 id="撤销commit操作"><a href="#撤销commit操作" class="headerlink" title="撤销commit操作"></a>撤销commit操作</h5><ul>
<li>1、找到上次git commit的commit_id</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2、完成撤销,同时将代码恢复到前一commit_id 对应的版本。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure>
<ul>
<li>或者2、完成Commit命令的撤销，但是不对代码修改进行撤销，可以直接通过git commit 重新提交对本地代码的修改。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset commit_id</span><br></pre></td></tr></table></figure>
<h3 id="三、查看、切换、删除、新建分支"><a href="#三、查看、切换、删除、新建分支" class="headerlink" title="三、查看、切换、删除、新建分支"></a>三、查看、切换、删除、新建分支</h3><h5 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<h5 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<h5 id="切换本地分支"><a href="#切换本地分支" class="headerlink" title="切换本地分支"></a>切换本地分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout xxx</span><br></pre></td></tr></table></figure>
<p>注意，每次切换分支，本地当前分支均不得有变动，否则需要先提交，在切换分支</p>
<h5 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -D xxx</span><br></pre></td></tr></table></figure>
<h5 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b xxx origin/master</span><br><span class="line">git push origin xxx</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>这样新建的分支，是从远程matser分支上新建的分支，并且当远程master分支代码更改时，执行git pull，本地代码也会同步远程master上代码更改。由此新建的分支，push代码时需用 git push origin xxx。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -b xxx</span><br><span class="line">git push</span><br><span class="line">git pull origin xxx</span><br></pre></td></tr></table></figure>
<p>需先切换至主分支，比如master上，这样新建的分支，执行git pull origin xxx，本地代码只会同步远程xxx分支上代码更改，不会同步远程master分支的代码。由此新建的分支，push代码时需用 git push 。</p>
<h3 id="四、解决冲突"><a href="#四、解决冲突" class="headerlink" title="四、解决冲突"></a>四、解决冲突</h3><h6 id="提交代码，最好是在gitlab上面合并分支，当提示有代码冲突时，关闭当前合并请求，并使用命令行按如下方式解决冲突。"><a href="#提交代码，最好是在gitlab上面合并分支，当提示有代码冲突时，关闭当前合并请求，并使用命令行按如下方式解决冲突。" class="headerlink" title="提交代码，最好是在gitlab上面合并分支，当提示有代码冲突时，关闭当前合并请求，并使用命令行按如下方式解决冲突。"></a>提交代码，最好是在gitlab上面合并分支，当提示有代码冲突时，关闭当前合并请求，并使用命令行按如下方式解决冲突。</h6><h6 id="主分支master-待合并分支-xugang"><a href="#主分支master-待合并分支-xugang" class="headerlink" title="主分支master,待合并分支 xugang"></a>主分支master,待合并分支 xugang</h6><ul>
<li>1、 git checkout xugang</li>
<li>2、 git pull</li>
<li>3、 git checkout master</li>
<li>4、 git pull</li>
<li>5、 git merge xugang （此时会提示存在冲突文件）</li>
<li>6、 git status         （查看存在冲突的文件）</li>
<li>7、 git diff           （查看冲突详情）</li>
<li>8、 在当前本地分支master上解决冲突，一定要本地运行，确保无误</li>
<li>9、 git push   </li>
<li>10、git checkout xugang   （这一步尤其重要，避免在master上直接更改代码。）</li>
</ul>
<h3 id="五、取消追踪-amp-追踪本地文件更改"><a href="#五、取消追踪-amp-追踪本地文件更改" class="headerlink" title="五、取消追踪&amp; 追踪本地文件更改"></a>五、取消追踪&amp; 追踪本地文件更改</h3><h5 id="取消追踪本地文件更改"><a href="#取消追踪本地文件更改" class="headerlink" title="取消追踪本地文件更改"></a>取消追踪本地文件更改</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git update-index --assume-unchanged src/config/server.json</span><br></pre></td></tr></table></figure>
<p>让git取消对server.json的track。</p>
<h5 id="恢复追踪本地文件更改"><a href="#恢复追踪本地文件更改" class="headerlink" title="恢复追踪本地文件更改"></a>恢复追踪本地文件更改</h5><pre><code>git update-index --no-assume-unchanged src/config/server.json
</code></pre><p>让git能够追踪记录到此文件</p>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/2017/12/21/hexo/</url>
    <content><![CDATA[<h5 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"xxxx"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="Installed-Extension"><a href="#Installed-Extension" class="headerlink" title="Installed Extension"></a>Installed Extension</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h5 id="Clear-Cache"><a href="#Clear-Cache" class="headerlink" title="Clear Cache"></a>Clear Cache</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<h5 id="Generate"><a href="#Generate" class="headerlink" title="Generate"></a>Generate</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<h5 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<h5 id="Simply"><a href="#Simply" class="headerlink" title="Simply"></a>Simply</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<h5 id="Local-debugging"><a href="#Local-debugging" class="headerlink" title="Local debugging"></a>Local debugging</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s -debug</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组方法使用小结</title>
    <url>/2017/12/20/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h5 id="1、filter-，“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组"><a href="#1、filter-，“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组" class="headerlink" title="1、filter()，“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组"></a>1、filter()，“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组</h5><ul>
<li>参数：function(item,index,arr)</li>
<li>不会更改原数组</li>
<li>有返回值，返回依条件返回的数组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr1 = [&#123;</span><br><span class="line">	name: <span class="string">'xugang'</span>,</span><br><span class="line">	age: 28</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	name: <span class="string">'wangran'</span>,</span><br><span class="line">	age: 27</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">const arr2 = arr1.filter((item)=&gt;&#123;</span><br><span class="line">	<span class="built_in">return</span> item.name === <span class="string">'xugang'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">arr2   // arr2 = [&#123;name:<span class="string">'xugang'</span>,age:28&#125;]</span><br><span class="line"></span><br><span class="line">以上可以简写为：</span><br><span class="line">const arr2 = arr1.filter(item=&gt;item.name === <span class="string">'xugang'</span>);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="2、map-，指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。"><a href="#2、map-，指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。" class="headerlink" title="2、map()，指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。"></a>2、map()，指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</h5><ul>
<li>参数：function(item,index,arr)</li>
<li>会更改原数组</li>
<li>有返回值，返回新的数组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [&#123;</span><br><span class="line">	animal: <span class="string">'dag'</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">	animal: <span class="string">'cat'</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">arr.map((item,index)=&gt;&#123;</span><br><span class="line">	item.color = <span class="string">'red'</span></span><br><span class="line">&#125;)</span><br><span class="line">arr   // arr = [&#123;animal: <span class="string">'dag'</span>,color: <span class="string">'red'</span>&#125;,&#123;animal: <span class="string">'cat'</span>,color: <span class="string">'red'</span>&#125;]</span><br></pre></td></tr></table></figure>
<h5 id="3、every-，判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。"><a href="#3、every-，判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。" class="headerlink" title="3、every()，判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。"></a>3、every()，判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</h5><ul>
<li>参数：function(item,index,arr)</li>
<li>不会更改原数组</li>
<li>有返回值: true or false</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1, 2, 3, 4, 5];</span><br><span class="line">const status = arr.every((item,index)=&gt;&#123;</span><br><span class="line">	<span class="built_in">return</span> item &lt; 10</span><br><span class="line">&#125;)   </span><br><span class="line">status // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">const status = arr.every((item,index)=&gt;&#123;</span><br><span class="line">	<span class="built_in">return</span> item &gt; 3</span><br><span class="line">&#125;)</span><br><span class="line">status // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h5 id="4、some-，判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。"><a href="#4、some-，判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。" class="headerlink" title="4、some()，判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。"></a>4、some()，判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</h5><ul>
<li>参数：function(item,index,arr)</li>
<li>不会更改原数组</li>
<li>有返回值: true or false</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1, 2, 3, 4, 5];</span><br><span class="line">const status = arr.some((item,index)=&gt;&#123;</span><br><span class="line">	<span class="built_in">return</span> item &lt; 2</span><br><span class="line">&#125;)   </span><br><span class="line">status // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">const status = arr.some((item,index)=&gt;&#123;</span><br><span class="line">	<span class="built_in">return</span> item &lt; 1</span><br><span class="line">&#125;)   </span><br><span class="line">status // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h5 id="4、forEach-，对数组进行遍历循环，对数组中的每一项运行给定函数。"><a href="#4、forEach-，对数组进行遍历循环，对数组中的每一项运行给定函数。" class="headerlink" title="4、forEach()，对数组进行遍历循环，对数组中的每一项运行给定函数。"></a>4、forEach()，对数组进行遍历循环，对数组中的每一项运行给定函数。</h5><ul>
<li>参数：function(item,index,arr)</li>
<li>不会更改原数组</li>
<li>没有返回值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [&#123;</span><br><span class="line">	name: <span class="string">'xugang'</span>,</span><br><span class="line">	age: 28</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	name: <span class="string">'wangran'</span>,</span><br><span class="line">	age: 27</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">let</span> arr1 = [];</span><br><span class="line">arr.forEach((item,index)=&gt;&#123;</span><br><span class="line">	<span class="keyword">if</span>(item.name === <span class="string">'wangran'</span>)&#123;</span><br><span class="line">		arr1.push(item.age)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">arr1   // [27]</span><br></pre></td></tr></table></figure>
<h5 id="5、slice-，返回从原数组中指定开始下标到结束下标之间的项组成的新数组。"><a href="#5、slice-，返回从原数组中指定开始下标到结束下标之间的项组成的新数组。" class="headerlink" title="5、slice()，返回从原数组中指定开始下标到结束下标之间的项组成的新数组。"></a>5、slice()，返回从原数组中指定开始下标到结束下标之间的项组成的新数组。</h5><ul>
<li>参数：接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始（包括指定位置）到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。如果开始下标或者结束下标出现负数，则加上原数组长度，转换为正数。</li>
<li>不会更改原数组</li>
<li>有返回值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1,2,3,4,5,6,7,8]</span><br><span class="line">const arr1 = arr.slice(2)   // [3,4,5,6,7,8]，从起始下标（包含起始下标）开始到数组结束</span><br><span class="line">const arr2 = arr.slice(2,5) // [3,4,5] ，从起始下标（包含起始下标）开始到结束下标（不包含结束下标）</span><br><span class="line">const arr3 = arr.slice(2,-2) // [3,4,5,6]，结束下标为（-2 + 8 = 6）</span><br><span class="line">const arr4 = arr.slice(-3,-2) // [6]，开始下标为（-3 + 8 = 5），结束下标为（-2 + 8 = 6）</span><br></pre></td></tr></table></figure>
<h5 id="6、splice-，很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。"><a href="#6、splice-，很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。" class="headerlink" title="6、splice()，很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。"></a>6、splice()，很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。</h5><ul>
<li>参数：接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始（包括指定位置）到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。如果开始下标或者结束下标出现负数，则加上原数组长度，转换为正数。</li>
<li>会更改原数组</li>
<li>有返回值，始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1,2,3,4,5,6,7,8]</span><br><span class="line">const arr1 = arr.slice(2)   // [3,4,5,6,7,8]，从起始下标（包含起始下标）开始到数组结束</span><br><span class="line">const arr2 = arr.slice(2,5) // [3,4,5] ，从起始下标（包含起始下标）开始到结束下标（不包含结束下标）</span><br><span class="line">const arr3 = arr.slice(2,-2) // [3,4,5,6]，结束下标为（-2 + 8 = 6）</span><br><span class="line">const arr4 = arr.slice(-3,-2) // [6]，开始下标为（-3 + 8 = 5），结束下标为（-2 + 8 = 6）</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 数组map()方法到底会不会改变原数组</title>
    <url>/2018/01/22/JS-%E6%95%B0%E7%BB%84map-%E6%96%B9%E6%B3%95%E5%88%B0%E5%BA%95%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>　　之前写过关于js数组map()的一篇文章，当时的结论是map()会改变原数组，后来仔细想了一下，其实这个结论很不严谨。那到底结论如何呢，先不慌，看以下两个示例：<br>　　<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr1 = [<span class="string">'xugang'</span>,<span class="string">'wangran'</span>]</span><br><span class="line">arr1.map((item,index)=&gt;&#123;</span><br><span class="line">	<span class="built_in">return</span> item += <span class="string">'good'</span></span><br><span class="line">&#125;)</span><br><span class="line">arr1 //arr1 = [<span class="string">'xugang'</span>,<span class="string">'wangran'</span>]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr2 = [&#123;</span><br><span class="line">	name: <span class="string">'xugang'</span>,</span><br><span class="line">	age: 29</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	name: <span class="string">'wangran'</span>,</span><br><span class="line">	age: 28</span><br><span class="line">&#125;]</span><br><span class="line">arr2.map((item,index)=&gt;&#123;</span><br><span class="line">	<span class="built_in">return</span> item.age += 1</span><br><span class="line">&#125;)</span><br><span class="line">arr2 //arr2 = [&#123;name:<span class="string">'xugang'</span>,age:30&#125;,&#123;name: <span class="string">'wangran'</span>,age:29&#125;]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>　　那么问题来了，为什么例子2原数组改变了，但例子1却没有更改呢？其实，这锅真不该map()来背！<br>　　我们知道，js数据类型分为基本数据类型和引用数据类型两种。其中，基本数据包括有Number、String、Null、Undefined、Boolean,引用数据类型包括有Object、Function、Awrry等。基本数据类型是按值传递，而引用数据类型是按引用传值。如下：
　　</p>
<h3 id="基本数据类型-amp-引用数据类型"><a href="#基本数据类型-amp-引用数据类型" class="headerlink" title="基本数据类型&amp;引用数据类型"></a>基本数据类型&amp;引用数据类型</h3><h5 id="1、基本数据类型："><a href="#1、基本数据类型：" class="headerlink" title="1、基本数据类型："></a>1、基本数据类型：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> a = <span class="string">'1'</span>;</span><br><span class="line"><span class="built_in">let</span> b = a;</span><br><span class="line">b = <span class="string">'2'</span>;</span><br><span class="line">a   // a = <span class="string">'1'</span></span><br></pre></td></tr></table></figure>
<p>　　本例中，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。基本数据类型都是保存在栈内存。</p>
<p><img src="https://pic002.cnblogs.com/images/2012/327530/2012062912181127.jpg" alt></p>
<h5 id="2、引用数据类型："><a href="#2、引用数据类型：" class="headerlink" title="2、引用数据类型："></a>2、引用数据类型：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var obj1 = new Object();</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj2.name = <span class="string">"xugang"</span>;</span><br><span class="line">console.log(obj1.name); // <span class="string">'xugang'</span></span><br></pre></td></tr></table></figure>
<p>　　本例中，这两个引用数据类型指向了同一个堆内存对象。obj1赋值给obj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2，但是实际上他们共同指向了同一个堆内存对象。实际上改变的是堆内存对象。<br>　　<br><img src="https://pic002.cnblogs.com/images/2012/327530/2012062914380085.jpg" alt></p>
<h5 id="3、总结两种数据类型区别点："><a href="#3、总结两种数据类型区别点：" class="headerlink" title="3、总结两种数据类型区别点："></a>3、总结两种数据类型区别点：</h5><ul>
<li>a、声明变量时不同的内存分配<ul>
<li>1、基本数据类型：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。</li>
<li>2、引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。</li>
</ul>
</li>
<li>b、不同的内存分配机制也带来了不同的访问机制<ul>
<li>1、在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。</li>
<li>2、而原始类型的值则是可以直接访问到的。</li>
</ul>
</li>
<li>c、 复制变量时的不同<ul>
<li>1、原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。</li>
<li>2、引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针</li>
</ul>
</li>
<li>d、 参数传递的不同（把实参复制给形参的过程）<br>  首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 <ul>
<li>1、原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。</li>
<li>2、引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript面向对象编程</title>
    <url>/2017/10/10/javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>Javascript是一种基于对象的语言，但是，又不是一种真正意义上的面向对象的语言，因为没有class（类）的语法。</p>
<h4 id="一、创建对象"><a href="#一、创建对象" class="headerlink" title="一、创建对象"></a>一、创建对象</h4><p>创建对象就是把属性（property）和方法（method）封装成一个对象，或者从原型对象中实例化一个对象。<br>下面以实例化小狗对象为例，小狗具有名字和品种两个属性。<br><a id="more"></a></p>
<h5 id="1、原始模式"><a href="#1、原始模式" class="headerlink" title="1、原始模式"></a>1、原始模式</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var dog1 = &#123;&#125;;</span><br><span class="line">dog1.name = <span class="string">'二牛'</span>;</span><br><span class="line">dog1.variety = <span class="string">'牛头梗'</span>;</span><br><span class="line"> </span><br><span class="line">var dog2 = &#123;&#125;;</span><br><span class="line">dog2.name = <span class="string">'二狗'</span>;</span><br><span class="line">dog2.variety = <span class="string">'哈士奇'</span>;</span><br></pre></td></tr></table></figure>
<p>这样封装对象虽然简单，但是有两个缺点，一是如果要创建多个实例的话，写起来会比较麻烦，二是这种写法并不能看出实例和原型之间有什么关系。<br>对原始模式进行改进，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Dog(name, variety) &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        variety: variety</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var dog1 = Dog(<span class="string">'二牛'</span>, <span class="string">'牛头梗'</span>);</span><br><span class="line">var dog2 = Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br></pre></td></tr></table></figure>
<p>改进后解决了代码重复的问题，但是dog1和dog2之间并没有内在联系，不是来自于同一个原型对象。</p>
<h5 id="2、构造函数模式"><a href="#2、构造函数模式" class="headerlink" title="2、构造函数模式"></a>2、构造函数模式</h5><p>构造函数，是内部使用了this的函数。通过new构造函数就能生成对象实例，并且this变量会绑定在实例对象上。使用构造函数可以解决从原型对象构建实例的问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Dog(name, variety) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.variety = variety;</span><br><span class="line">&#125;</span><br><span class="line">var dog1 = new Dog(<span class="string">'二牛'</span>, <span class="string">'牛头梗'</span>);</span><br><span class="line">var dog2 = new Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog1.name); // 二牛</span><br><span class="line"><span class="built_in">print</span>(dog2.name); // 二狗</span><br></pre></td></tr></table></figure>
<p>验证实例对象与原型对象之间的关系：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(dog1.cunstructor === Dog); // <span class="literal">true</span></span><br><span class="line"><span class="built_in">print</span>(dog2.cunstructor === Dog); // <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(dog1 instanceof Dog); // <span class="literal">true</span></span><br><span class="line"><span class="built_in">print</span>(dog2 instanceof Dog); // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">这样看来构造函数模式解决了原始模式的缺点，但是它自己又引入了新的缺点，就是有些时候存在浪费内存的问题。比如说，我们现在要给小狗这个对象添加一个公共的属性“<span class="built_in">type</span>”（种类）和一个公共方法“bark”（吠）：</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Dog(name, variety) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.variety = variety;</span><br><span class="line">    this.type = <span class="string">'犬科'</span>;</span><br><span class="line">    this.bark = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'汪汪汪'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再去实例化对象，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(dog1.bark() === dog2.bark()); // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>从中我们可以看出问题，那就是对于每个实例对象而言，type属性和bark方法都是一样的，但是每次创建新的实例，都要为其分配新的内存空间，这样做就会降低性能，浪费空间，缺乏效率。<br>接下来我们就要思考怎样让这些所有实例对象都相同的内容在内存中只生成一次，并且让所有实例的这些相同内容都指向那个内存地址？</p>
<h5 id="3、Prototype模式"><a href="#3、Prototype模式" class="headerlink" title="3、Prototype模式"></a>3、Prototype模式</h5><p>每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。可以利用这一点，把那些不变的属性和方法，定义在prototype对象上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Dog(name, variety) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.variety = variety;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.type = <span class="string">'犬科'</span>;</span><br><span class="line">Dog.prototype.bark = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'汪汪汪'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var dog1 = new Dog(<span class="string">'二牛'</span>, <span class="string">'牛头梗'</span>);</span><br><span class="line">var dog2 = new Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(dog1.type); // 犬科</span><br><span class="line">dog1.bark(); // 汪汪汪</span><br><span class="line"><span class="built_in">print</span>(dog2.type); // 犬科</span><br><span class="line">dog2.bark(); // 汪汪汪</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(dog1.bark() === dog2.bark()); // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这里所有实例对象的type属性和bark方法，都指向prototype对象，都是同一个内存地址。</p>
<h4 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 现在有一个动物的构造函数：</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Animal</span></span>() &#123;</span><br><span class="line">    this.feeling = <span class="string">'happy'</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 有一个小狗的构造函数：</span><br><span class="line"><span class="keyword">function</span> Dog(name, variety) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.variety = variety;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下如不对Animal和Dog对象进行重写，则使用该代码进行代入，示例代码中不再重复。</p>
<h5 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Dog.prototype = new Animal();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line">var dog = new Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog.feeling); // happy</span><br></pre></td></tr></table></figure>
<p>原型链继承存在两个问题：第一点是当被继承对象中包含引用类型的属性时，该属性会被所有实例对象共享，示例代码如下；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Animal</span></span>() &#123;</span><br><span class="line">    this.colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Dog</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 继承Animal</span><br><span class="line">Dog.prototype = new Animal();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"> </span><br><span class="line">var dog1 = new Dog();</span><br><span class="line">dog1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog1.colors); // red,green,blue,black</span><br><span class="line"> </span><br><span class="line">var dog2 = new Dog();</span><br><span class="line"><span class="built_in">print</span>(dog2.colors); // red,green,blue,black</span><br></pre></td></tr></table></figure>
<p>第二点是不能在不影响所有实例对象的情况下，向父级构造函数传递参数，这一点不做示例，大家可以自行验证下；</p>
<h5 id="2、构造函数继承"><a href="#2、构造函数继承" class="headerlink" title="2、构造函数继承"></a>2、构造函数继承</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Dog(name, variety) &#123;</span><br><span class="line">    Animal.apply(this, arguments);</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.variety = variety;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var dog = new Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog.feeling); // happy</span><br></pre></td></tr></table></figure>
<p>这是一种十分简单的方法，使用apply或者call方法改变构造函数作用域，将父函数的构造函数绑定到子对象上。虽然解决了子对象向父对象传递参数的目的，但是借助构造函数，方法都在构造函数中定义，函数的复用就无从谈起。</p>
<h5 id="3、构造函数和原型链组合继承"><a href="#3、构造函数和原型链组合继承" class="headerlink" title="3、构造函数和原型链组合继承"></a>3、构造函数和原型链组合继承</h5><p>利用构造函数实现对实例属性的继承，使用原型链完成对原型属性和方法的继承，避免了原型链和构造函数的缺陷。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Animal(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.sayName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> Dog(name, age) &#123;</span><br><span class="line">    // 继承属性</span><br><span class="line">    Animal.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">// 继承方法</span><br><span class="line">Dog.prototype = new Animal();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line">Dog.prototype.sayAge = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(this.age);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var dog1 = new Dog(<span class="string">'二狗'</span>, 1);</span><br><span class="line">dog1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog1.colors); // red,green,blue,black</span><br><span class="line">dog1.sayName(); // 二狗</span><br><span class="line">dog1.sayAge(); // 1</span><br><span class="line"> </span><br><span class="line">var dog2 = new Dog(<span class="string">'二牛'</span>, 2);</span><br><span class="line"><span class="built_in">print</span>(dog2.colors); // red,green,blue</span><br><span class="line">dog2.sayName(); // 二牛</span><br><span class="line">dog2.sayAge(); // 2</span><br></pre></td></tr></table></figure>
<h5 id="4、YUI式继承"><a href="#4、YUI式继承" class="headerlink" title="4、YUI式继承"></a>4、YUI式继承</h5><p>由原型链继承延伸而来，避免了实例对象的prototype指向同一个对象的缺点（Dog.prototype包含一内部指针指向Animal.prototype，同时Dog的所有实例也都包含一内部指针指向Dog.prototype，那么任何对Dog实例上继承自Animal的属性或方法的修改，都会反映到Dog.prototype）。让Dog跳过Animal，直接继承Animal.prototype，这样省去执行和创建Animal实例，提高了效率。利用一个空对象作为媒介，空对象几乎不占用内存，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Animal</span></span>() &#123;&#125;</span><br><span class="line">Animal.prototype.feeling = <span class="string">'happy'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> extend(Child, Parent) &#123;</span><br><span class="line">    var F = <span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">    F.prototype = Parent.prototype;</span><br><span class="line">    Child.prototype = new F();</span><br><span class="line">    Child.prototype.constructor = Child;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">extend(Dog, Animal);</span><br><span class="line"> </span><br><span class="line">var dog = new Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog.feeling); // happy</span><br></pre></td></tr></table></figure>
<h5 id="5、拷贝继承（浅拷贝和深拷贝）"><a href="#5、拷贝继承（浅拷贝和深拷贝）" class="headerlink" title="5、拷贝继承（浅拷贝和深拷贝）"></a>5、拷贝继承（浅拷贝和深拷贝）</h5><p>把父对象的属性和方法，全部拷贝给子对象，也能实现继承。</p>
<h6 id="①-浅复制"><a href="#①-浅复制" class="headerlink" title="① 浅复制"></a>① 浅复制</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Animal</span></span>() &#123;&#125;</span><br><span class="line">Animal.prototype.feeling = <span class="string">'happy'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> extend(Child, Parent) &#123;</span><br><span class="line">    var p = Parent.prototype;</span><br><span class="line">    var c = Child.prototype;</span><br><span class="line">    <span class="keyword">for</span> (var i <span class="keyword">in</span> p) &#123;</span><br><span class="line">        c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">extend(Dog, Animal);</span><br><span class="line"> </span><br><span class="line">var dog = new Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog.feeling); // happy</span><br></pre></td></tr></table></figure>
<p>但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能,比如在上例中适当位置添加如下代码会发现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Animal.prototype.colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"> </span><br><span class="line">Dog.colors.push(<span class="string">'black'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(Dog.colors); // red,green,blue,black</span><br><span class="line"><span class="built_in">print</span>(Animal.colors); // red,green,blue,black</span><br></pre></td></tr></table></figure>
<p>当然，这也是jquery早期实现继承的方式。</p>
<h6 id="②-深复制"><a href="#②-深复制" class="headerlink" title="② 深复制"></a>② 深复制</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Animal</span></span>() &#123;&#125;</span><br><span class="line">Animal.prototype.feeling = <span class="string">'happy'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> deepCopy(Child, Parent) &#123;</span><br><span class="line">    var p = Parent.prototype;</span><br><span class="line">    var c = Child.prototype;</span><br><span class="line">    <span class="keyword">for</span> (var i <span class="keyword">in</span> p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof p[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">            c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</span><br><span class="line">            deepCopy(p[i], c[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c[i] = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">deepCopy(Dog, Animal);</span><br><span class="line"> </span><br><span class="line">var dog = new Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog.feeling); // happy</span><br></pre></td></tr></table></figure>
<p>深拷贝，能够实现真正意义上的数组和对象的拷贝。这时，在子对象上修改属性（引用类型），就不会影响到父元素了。这也是目前jquery使用的继承方式</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下mysql入门</title>
    <url>/2017/12/11/mac%E4%B8%8Bmysql%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>之前学过一点时间node，但是断断续续掌握的并不系统，前几个月从上海回到武汉，总算体验了回离家近的感觉，也有时间开始捣鼓一些一直想要做的事情了。</p>
</blockquote>
<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>mac系统下node，很简单就不赘述了，直接百度~</p>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul>
<li>1、<a href="https://share.weiyun.com/658f9a3fe0e7cd6b06ee938969d48576" target="_blank" rel="noopener">MySQL(mac版)</a></li>
<li>2、<a href="https://share.weiyun.com/ab82e4951788e1adec30e6b09aae5309" target="_blank" rel="noopener">Navicat for MySQL(mac破解版)</a></li>
</ul>
<a id="more"></a>
<h4 id="MySQL安装步骤"><a href="#MySQL安装步骤" class="headerlink" title="MySQL安装步骤"></a>MySQL安装步骤</h4><ul>
<li>1、 双击 .dmg 文件，开始安装，一直点击继续，直到最后一步出现如下弹框：</li>
<li>2、 将root账号的初始密码保存，此密码非常重要，切记保存,点击ok，完成安装</li>
<li>3、 进入系统偏好与设置，点击左下角MySQL应用图标，运行服务，并且在启动页面点击“run MySQL Server”按钮。</li>
</ul>
<h4 id="MySQL环境变量配置"><a href="#MySQL环境变量配置" class="headerlink" title="MySQL环境变量配置"></a>MySQL环境变量配置</h4><ul>
<li>1、打开命令行，输入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p>此时会提示“commod not found”，因为此时我们还未将mysql加入系统环境变量；</p>
<ul>
<li>2、ls，查看此目录下是否有mysql</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local/mysql/bin</span><br></pre></td></tr></table></figure>
<ul>
<li>3、命令行输入：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>在该文件中添加mysql/bin的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PATH=$PATH:/u sr/local/mysql/bin</span><br></pre></td></tr></table></figure>
<ul>
<li>4、添加完成后，按esc，接着按大写键（caps lock），再按Q，再切换成小写，输入wq，退出并保存该文件；</li>
<li>5、现在可以登录mysql了，此时会提示输入密码，该密码即刚才反复强调需要保存的密码。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<h4 id="修改MySQL初始密码"><a href="#修改MySQL初始密码" class="headerlink" title="修改MySQL初始密码"></a>修改MySQL初始密码</h4><ul>
<li>1、在系统偏好与设置内，运行MySQL</li>
<li>2、连接server,命令行输入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<ul>
<li>3、输入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE mysql.user SET authentication_string=PASSWORD(&apos;123456&apos;) WHERE User=&apos;root&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、如果出现ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement ；则需要</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set password=password(&apos;123456&apos;);</span><br></pre></td></tr></table></figure>
<p>//此处密码必须跟上面设置的密码一样；  </p>
<ul>
<li>4、输入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<ul>
<li>5、按quit;退出</li>
</ul>
<h4 id="使用图形化工具-Navicat-for-MySQL"><a href="#使用图形化工具-Navicat-for-MySQL" class="headerlink" title="使用图形化工具 Navicat for MySQL"></a>使用图形化工具 Navicat for MySQL</h4><ul>
<li>1、单击下载好的Navicat,按照提示，打开应用</li>
<li>2、新建连接，输入对应配置信息，其中连接名可以随便填写</li>
<li>3、点击连接测试，确定连接成功</li>
</ul>
<h4 id="卸载MySQL"><a href="#卸载MySQL" class="headerlink" title="卸载MySQL"></a>卸载MySQL</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/local/mysql</span><br><span class="line">sudo rm -rf /usr/local/mysql*</span><br><span class="line">sudo rm -rf /Library/StartupItems/MySQLCOM</span><br><span class="line">sudo rm -rf /Library/PreferencePanes/My*</span><br><span class="line">rm -rf ~/Library/PreferencePanes/My*</span><br><span class="line">sudo rm -rf /Library/Receipts/mysql*</span><br><span class="line">sudo rm -rf /Library/Receipts/MySQL*</span><br><span class="line">sudo rm -rf /var/db/receipts/com.mysql.</span><br></pre></td></tr></table></figure>
<p>调用vim /etc/hostconfig，删除 MYSQLCOM=-YES-这一行。</p>
<h4 id="常用命令行操作"><a href="#常用命令行操作" class="headerlink" title="常用命令行操作"></a>常用命令行操作</h4><ul>
<li><p>创建一个名字为mydatabase数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database mydatabase;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看创建的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改数据库名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter databases Hdatabase;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mydatabase;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看该数据库中的表</p>
</li>
</ul>
<pre><code>show tables;
</code></pre><ul>
<li>创建表</li>
</ul>
<pre><code class="bash">create table student (
          name varchar(10) , 
          gender varchar(10) , 
          sno int primary key(id)
         )charset utf8;
</code></pre>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>react dva学习心得</title>
    <url>/2017/10/16/react-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>　　前端技术日新月异，三大框架盛行的年代，正是web developer 大展宏图的好时期。选择何种框架，要根据公司实际业务。比如我现在公司是做企业后台，业务逻辑复杂，客户对表格的要求很高，这种情况下，使用react会比较合适，特别是基于react和redux的最佳实践dva框架，体验非常好！但是像之前上海的公司，只涉及微信商城构建，主要难点是订单流，业务不算复杂，这种情况下，使用vue会更加合适。轻量、高效，上手快，是小公司的绝佳选择。
　　
　　</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>作用域&amp;作用域链</title>
    <url>/2020/12/01/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    <content><![CDATA[<blockquote>
<p>一步一步重温 <strong>JavaScript</strong> 基础系列。<br>本章节将会理解JS的作用域、作用域链以及延长作用域链。</p>
</blockquote>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><strong>作用域</strong>就是变量和函数的可访问范围。</p>
<a id="more"></a>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域</p>
<ul>
<li>window 对象的内置属性都拥有全局作用域；</li>
<li>定义在最外层的函数和变量拥有全局作用域；</li>
<li>所有未定义但直接赋值的变量也拥有全局作用域。</li>
</ul>
<h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所以也称为函数作用域</p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>意思是由花括号封闭的代码块有自己的作用域</p>
<ul>
<li><p><strong>没有块级作用域</strong>，es6之前，js没有块级作用域，由此会产生问题:<strong>在if或者for循环中声明的变量会泄露成全局变量</strong></p>
<p>  代码理解如下：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 例子1：</span><br><span class="line">if(true) &#123;</span><br><span class="line">  var color = &apos;blue&apos;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(color)</span><br><span class="line">// 在if语句中声明的变量，会被添加至if语句当前的执行环境中（此时为全局作用域）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 例子2：</span><br><span class="line">for(var i=0;i &lt; 10; i ++)&#123;</span><br><span class="line">  // doSomeThing(i)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;i:&apos;, i)</span><br><span class="line">// 结果会返回10，对于有块级作用域的语言来说，for语句内定义的变量，只会存在于循环体内，</span><br><span class="line">   // 而es6之前，js没有块级作用域，由for语句定义的变量i，即使for循环结束后，也依旧存在于for语句所在的执行环境中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 例子3：</span><br><span class="line">var temp = &apos;green&apos;;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(temp);</span><br><span class="line">  if(false) &#123;</span><br><span class="line">    var temp = &apos;blue&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">// 结果打印为&apos;undefined&apos;。</span><br><span class="line"></span><br><span class="line">// 虽然按照我们常规理解，由于if语句内部代码并不会被执行，在foo函数作用域内，没有temp变量的值， </span><br><span class="line">   // 此时向上查找到全局作用域确定temp变量的值为green。</span><br><span class="line">   // 但是由于js没有块级作用域，if语句中声明的变量，会被添加至if语句所在的执行环境中，</span><br><span class="line">   // 所以在变量提升的前提下，此时temp值为 &apos;undefined&apos;。</span><br></pre></td></tr></table></figure>
<p>  <strong>注意：if语句如果不满足条件，if语句内部代码块不会被执行，但是内部声明的变量（不包括函数）仍然会被添加至if语句所在的执行环境中，此时该变量的值初始化为undefined</strong></p>
</li>
<li><p><strong>模仿块级作用域</strong>，ES6以前变量的作用域是函数范围，有时在函数内局部需要一些临时变量，因为没有块级作用域，所以就会将局部代码封装到IIEF（立即执行函数）中。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 立即执行函数</span><br><span class="line">(function()&#123;</span><br><span class="line">  var temp = &quot;hello world&quot;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// 块级作用域</span><br><span class="line">&#123;</span><br><span class="line">  var temp = &quot;hello world&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>es6块级块级作用域</strong>， 用let命令新增了块级作用域，外层作用域无法获取到内层作用域</p>
<ul>
<li><p>外层作用域无法获取到内层作用域， 比如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 例子1</span><br><span class="line">function fn1() &#123;</span><br><span class="line">  var a = 41;</span><br><span class="line">  if(1 == 1) &#123;</span><br><span class="line">    var a = 3;</span><br><span class="line">    console.log(2,a); // 2 3</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(1,a); // 1 3</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br><span class="line">// 打印结果为：2 3 和 1 3</span><br><span class="line"></span><br><span class="line">// 例子2</span><br><span class="line">function fn2() &#123;</span><br><span class="line">  let a = 41;</span><br><span class="line">  if(1 == 1) &#123;</span><br><span class="line">    let a = 3;</span><br><span class="line">    console.log(2,a); // 2 3</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(1,a); // 1 41</span><br><span class="line">&#125;</span><br><span class="line">fn2();</span><br><span class="line">// 打印结果为：2 3 和 1 41</span><br></pre></td></tr></table></figure>
</li>
<li><p>外层和内层都使用相同变量名，也都互不干扰，比如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  &#123;</span><br><span class="line">    let name = &apos;xug&apos;;</span><br><span class="line">    console.log(name); // xug</span><br><span class="line">  &#125;</span><br><span class="line">  let name = &apos;suifeng&apos;;</span><br><span class="line">  console.log(name); // suifeng</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>明白了块级作用域，模仿块级作用域，咱们再来道老生常谈的旧菜测试一下：<strong>如何在for循环中，依次打印出 0,1,2 ?</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 方式①  使用自执行匿名函数，模仿块级作用域</span><br><span class="line">for (var i=0; i &lt; 3; i ++) &#123;</span><br><span class="line">  (function (a) &#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式② 使用es6 let，自带块级作用域</span><br><span class="line">for (let i=0; i &lt; 3; i ++) &#123;</span><br><span class="line">  console.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在确定一个变量的值时，首先会从当前所在的局部作用域内查找，如果找到则停止，否则就会在上级作用域内查找，直到全局作用域。这个逐级向上查找形成的链条，就称之为<strong>作用域链</strong>。</p>
<p>来道小菜，测试一下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var scope = &quot;global&quot;;</span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(scope);</span><br><span class="line">    var scope = &quot;local&quot;;</span><br><span class="line">    console.log(scope);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">// 打印结果为：&apos;undefined&apos;, &apos;local&apos;</span><br><span class="line"></span><br><span class="line">// 在函数foo内部，由于存在变量提升，scope首先会被赋值为&apos;undefined&apos;，</span><br><span class="line">// 也就是说在函数作用域内已经找到scope变量的值，查找结束，所以第一个打印为&apos;undefined&apos;。</span><br><span class="line">// 接着，进行变量重新赋值，所以第二个打印为&apos;local&apos;。当然了，这道题的考点主要在变量提升，咱们接着聊。</span><br></pre></td></tr></table></figure></p>
<h2 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h2><p>虽然执行环境只有全局执行环境和局部执行环境，但是有些语句可以<strong>接收一个对象，也就是在当前作用域的最前端临时增加一个变量对象，从而起到了延长作用域链的作用</strong></p>
<ul>
<li><p>try-catch 语句中的catch块<br>catch语句，会创建一个新的变量对象，其中包含的是被抛出来的错误对象的声明</p>
</li>
<li><p>with语句<br>with语句，会将指定的对象添加到作用域链最前端</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function buildUrl () &#123;</span><br><span class="line">  var qs = &apos;?debug=true&apos;;</span><br><span class="line"></span><br><span class="line">  with (location) &#123;</span><br><span class="line">    var url = href + qs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return url;</span><br><span class="line">&#125;</span><br><span class="line">buildUrl();</span><br></pre></td></tr></table></figure>
<p>在这里，with语句接收一个location对象，因此其变量对象就包含了location对象的所有属性和方法，而这个变量对象被添加至作用域链的前端。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS变量</title>
    <url>/2020/11/22/%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<blockquote>
<p>一步一步重温 <strong>JavaScript</strong> 基础系列。<br>本章节将会理解JS的变量，包括变量的含义、变量的值、复制变量的值，以及传递参数</p>
</blockquote>
<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>JavaScipt变量松散类型的本质，决定了变量只是在特定时间内用于保存特定值的一个名字，或者称之为引用。</p>
<a id="more"></a>
<h2 id="2-变量的值"><a href="#2-变量的值" class="headerlink" title="2 变量的值"></a>2 变量的值</h2><p>分为基本类型变量的值，和引用类型变量的值。其中，基本类型变量的值大小固定，存放于栈内存中，允许直接操作，即基本类型变量是按值访问；而引用数据类型变量的值大小不固定，存放于堆内存中，不可直接访问，其引用地址（即变量）存放于栈内存中，故引用数据类型变量的值是按引用访问。</p>
<h2 id="3-复制变量的值"><a href="#3-复制变量的值" class="headerlink" title="3 复制变量的值"></a>3 复制变量的值</h2><ul>
<li><p><strong>值为基本数据类型的变量</strong>，与复制后形成的变量，相互独立，后续赋值各不相干；</p>
</li>
<li><p><strong>值为引用数据类型的变量</strong>，复制时，实际上是复制一个指针（或称之为引用），共同指向堆内存中的同一对象。当其中一个变量操作该对象的属性时，另外一个变量对应的属性也会随之改变，因为他们指向的是同一个对象。</p>
</li>
</ul>
<p>实例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 值为基本数据类型的变量</span><br><span class="line">var num1 = 5;</span><br><span class="line">var num2 = num1;</span><br><span class="line">num2 ++;</span><br><span class="line"></span><br><span class="line">console.log(num1)  // 5</span><br><span class="line">console.log(num2)  // 6</span><br><span class="line"></span><br><span class="line">// 值为引用数据类型的变量</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">  name: &apos;xugang&apos;,</span><br><span class="line">  age: 30</span><br><span class="line">&#125;</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj2.age = 32</span><br><span class="line"></span><br><span class="line">console.log(obj1.age)  // 32</span><br></pre></td></tr></table></figure></p>
<p>图解如下：</p>
<p><img src="/images/复制变量值.jpg" alt="复制变量的值图解"></p>
<h2 id="4-变量作为参数传递-–-JS中所有函数的参数都是按值传递"><a href="#4-变量作为参数传递-–-JS中所有函数的参数都是按值传递" class="headerlink" title="4 变量作为参数传递 – JS中所有函数的参数都是按值传递"></a>4 变量作为参数传递 – JS中所有函数的参数都是按值传递</h2><p>函数在传递参数时，就是把实参复制给形参，即函数的局部变量。如果实参是引用数据类型，则复制形成的行参和实参相互独立，互不影响；如果是引用数据类型，此时，实参复制的是一份指针，共同指向堆内存中的同一对象，所以此时修改形参的属性或属性值，则会影响对应实参的属性和属性值。</p>
<p><strong>那如何理解函数中参数传递，是按值传递，而不是按引用传递？</strong></p>
<ol>
<li>如果为按值传递，则复制的是一个指针，共同指向堆内存中的同一对象，此时形参属性和属性值的改变，会影响外部实参的属性和属性值；</li>
<li>如果为按引用传递，则意味着传递整个变量，此时如果改变局部变量即形参的引用地址，也会相应改变实参的引用地址，这显然和实际不符。</li>
</ol>
<p><strong>总结如下：</strong><br>所谓变量作为参数传递是按值传递，是指将外部变量（实参）的值复制给内部局部变量（实参），也就是在栈内存中复制出一份指针，共同指向堆内存的同一对象。函数内部可以通过改变形参的属性和属性值来改变，外部变量（实参）对应的属性和属性值， 但是不能操作外部变量（实参）本身。图解如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setName(obj) &#123;</span><br><span class="line">  obj.name = &apos;xugang&apos;;</span><br><span class="line">  </span><br><span class="line">  // 改变局部变量（形参）的引用地址，指向堆内存中的一个新对象</span><br><span class="line">  obj = new Object();</span><br><span class="line">  obj.name = &apos;suifeng&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Object();</span><br><span class="line">setName(person);</span><br><span class="line"></span><br><span class="line">console.log(person) // &#123;name: &apos;xugang&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>图解如下：</p>
<p><img src="/images/按值传递.jpg" alt="按值传递图解"></p>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo + github + Yilia搭建个人博客</title>
    <url>/2017/12/22/%E4%BD%BF%E7%94%A8hexo-github-Yilia%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>大概是在半年前，自己花了大半天的时间摸索，终于搭建好了基于hexo+github的博客，这几天正好有个同事请教我，借此机会写个教程，免得后面遗忘。</p>
<ul>
<li>注*：和其他教程一样，本教程同样只适用于mac用户</li>
</ul>
</blockquote>
<h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><ul>
<li>1、 搭建node环境（省略）</li>
<li>2、 安装git（省略）</li>
<li>3、 确认以上安装成功，命令行分别输入，出现版本号，即表示安装成功</li>
</ul>
<a id="more"></a>
<pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">git -v</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>4、我之前写过<a href="https://suifengcool.github.io/2017/12/13/git-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">git常用命令的小结</a>，大家可以参考下</li>
</ul>
<h3 id="在github上创建pages项目"><a href="#在github上创建pages项目" class="headerlink" title="在github上创建pages项目"></a>在github上创建pages项目</h3><ul>
<li>1、 注册github，登录，此步骤省略</li>
<li>2、 在<a href="https://github.com/" target="_blank" rel="noopener">github官网</a>，点击右上角“+”，选择New repository，进入项目创建页</li>
<li>3、 在”Repository name”输入框内输入“xxx.github.io”，其中“xxx”对应自己的用户名</li>
<li>4、 点击底部按钮“Create repository”，完成创建，跳转至该项目页</li>
<li>5、 点击右上角Settings，跳至设置页，下拉找到GitHub Pages栏，先点击Choose a Theme，然后再点击save按钮。此时，github.io已经可以访问了。</li>
</ul>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><ul>
<li><p>全局安装hexo脚手架</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo -v     // 出现版本号则安装成功，那么hexo安装成功</span><br></pre></td></tr></table></figure>
</li>
<li><p>hexo初始化项目</p>
</li>
</ul>
<pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>本地运行</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s -debug</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>此时，浏览器输入<a href="localhost:4000" target="_blank" rel="noopener">localhost:4000</a>，就可以看到项目运行了。</p>
<h3 id="将hexo和github绑定"><a href="#将hexo和github绑定" class="headerlink" title="将hexo和github绑定"></a>将hexo和github绑定</h3><ul>
<li><p>安装部署工具</p>
<pre><code class="bash">npm install hexo-deployer-git -save
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>setTimeout详解</title>
    <url>/2018/03/12/setTimeout%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>变量声明&amp;函数声明</title>
    <url>/2020/12/01/%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<blockquote>
<p>一步一步重温 <strong>JavaScript</strong> 基础系列。<br>本章节将会理解JS的变量和函数的声明方式和异同，以及其优先级</p>
</blockquote>
<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><a id="more"></a>
<h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针。</p>
<ul>
<li>定义的变量没有赋值时，默认初始化为undefined</li>
<li>没有块级作用域</li>
<li>存在变量声明提升</li>
<li>可以反复声明和赋值</li>
</ul>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错。</p>
<ul>
<li>有块级作用域，只在声明所在的块级作用域内有效</li>
<li>没有变量声明提升</li>
<li>不可重复声明</li>
</ul>
<h3 id="const-常量"><a href="#const-常量" class="headerlink" title="const 常量"></a>const 常量</h3><p>声明常量，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性。</p>
<ul>
<li>有块级作用域，只在声明所在的块级作用域内有效</li>
<li>没有变量声明提升</li>
<li>不可重复声明</li>
<li>声明时必须初始化赋值</li>
</ul>
<p>（以上非原创）链接：<a href="https://www.jianshu.com/p/12c186deb6fe" target="_blank" rel="noopener">https://www.jianshu.com/p/12c186deb6fe</a></p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo ()&#123;</span><br><span class="line">  // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo = function ()&#123;</span><br><span class="line">  // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将用函数表达式定义的函数理解为先声明一个变量，然后赋值为一个函数<br><strong>注意：函数声明存在函数声明提升，而函数表达式则没有</strong><br>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 函数声明-存在函数声明提升</span><br><span class="line">sayHi();</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    alert(&apos;Hi&apos;)</span><br><span class="line">&#125;</span><br><span class="line">// 此时不会报错，因为函数声明提升，即将函数声明方式定义的函数，放在最先进行读取</span><br><span class="line"></span><br><span class="line">// 函数表达式-不存在函数声明提升</span><br><span class="line">sayHi();</span><br><span class="line">var sayHi = function () &#123;</span><br><span class="line">    alert(&apos;Hi&apos;)</span><br><span class="line">&#125;</span><br><span class="line">// 此时会报错，因为变量声明提升，在当前作用域下，先声明一个sayHi，但并未赋值，其值默认为&apos;undefined&apos;</span><br><span class="line">// 一个值为&apos;undefined&apos;的变量，作为函数调用，显然会报错</span><br></pre></td></tr></table></figure></p>
<h2 id="函数声明和变量声明提升优先级"><a href="#函数声明和变量声明提升优先级" class="headerlink" title="函数声明和变量声明提升优先级"></a>函数声明和变量声明提升优先级</h2><ul>
<li><p>函数声明优先级高于变量声明，毕竟函数是一等公民</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getNum = function()&#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;</span><br><span class="line">function getNum ()&#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">getNum();</span><br><span class="line"></span><br><span class="line">// 打印为2</span><br><span class="line">// 代码解释如下：</span><br><span class="line">function getNum ()&#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getNum;</span><br><span class="line">getNum = function()&#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getNum();</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数声明，如果有同名属性，后面会替换前面</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>基于react框架Dva下点击事件及获取点击数据</title>
    <url>/2017/10/19/%E5%9F%BA%E4%BA%8Ereact%E6%A1%86%E6%9E%B6Dva%E4%B8%8B%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%8F%8A%E8%8E%B7%E5%8F%96%E7%82%B9%E5%87%BB%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h5 id="1-有状态的组件"><a href="#1-有状态的组件" class="headerlink" title="1.有状态的组件"></a>1.有状态的组件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bindOff = (e) =&gt; &#123;</span><br><span class="line">	<span class="built_in">let</span> Token = cookie.load(<span class="string">'userdata'</span>);</span><br><span class="line">	message.info(<span class="string">'解绑成功！'</span>)</span><br><span class="line">	_EquipmentIndex.props.dispatch(&#123;</span><br><span class="line">		<span class="built_in">type</span>: <span class="string">'Equipment/BindRoute'</span>,</span><br><span class="line">		payload: &#123;</span><br><span class="line">			companyId:Token.companyId,</span><br><span class="line">			deviceId:e</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">&lt;a onClick=&#123;()=&gt;this.bindOff(record)&#125;&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="2-无状态的组件"><a href="#2-无状态的组件" class="headerlink" title="2.无状态的组件"></a>2.无状态的组件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">handleSubmite(e) &#123;</span><br><span class="line">	console.log(<span class="string">'点击事件'</span>)</span><br><span class="line">&#125;	</span><br><span class="line">&lt;Button onClick=&#123;handleSubmit(e)&#125;&gt;点击&lt;/Button&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>解决使用axios后POST请求会出现OPTIONS预请求问题</title>
    <url>/2018/03/27/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8axios%E5%90%8EPOST%E8%AF%B7%E6%B1%82%E4%BC%9A%E5%87%BA%E7%8E%B0OPTIONS%E9%A2%84%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>Vue 的作者尤雨溪几个月前发表了一篇博客，表示 vue-resource 将不再是官方推荐的库，建议大家以 axios 替代。由此，开始了使用 axios 的历程，但是实践发现每次POST请求，都会先发送一个OPTIONS的请求，然后再发送正常的POST请求。</p>
</blockquote>
<a id="more"></a>
<p>查了一些资料，发现这个问题，其实并不复杂。<br>　　<br>跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。 </p>
<p>也就是说，它会先使用options去测试，你这个接口是否能够正常通讯，如果不能就不会发送真正的请求过来，如果测试通讯正常，则开始正常请求。 </p>
<p>关于这个问题，需要在后台接口进行设置，允许options请求，不然你的请求就会受到影响。如果请求方式为options，告诉它可以通讯，其他直接什么都不做。</p>
<p><strong>那么问题来了，怎么避免额外发送options请求的问题？</strong><br>　　<br>1、Vue 使用，只需要把格式为json的参数用qs插件转换一下就好了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 第一步：安装qs</span><br><span class="line">npm install qs</span><br><span class="line"></span><br><span class="line">// 第二步：main.js</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">import qs from &apos;qs&apos;</span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios</span><br><span class="line">Vue.prototype.$qs = qs</span><br><span class="line"></span><br><span class="line">// 第三步：（页面调用）</span><br><span class="line">this.$http(&#123;</span><br><span class="line">    method: &apos;post&apos;,</span><br><span class="line">    url: &apos;http://localhost:3000/user/login&apos;,</span><br><span class="line">        data: this.$qs.stringify(&#123;</span><br><span class="line">            account: &apos;xugang&apos;,</span><br><span class="line">            passwd: &apos;123456&apos;,</span><br><span class="line">            email: &apos;371801080@qq.com&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(function (response) &#123;</span><br><span class="line">        console.log(response);</span><br><span class="line">    &#125;).catch(function (error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2020/12/02/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<blockquote>
<p>一步一步重温 <strong>JavaScript</strong> 基础系列。<br>本章节将会理解JS的闭包、闭包为何会造成内存泄漏，以及闭包相关考题</p>
</blockquote>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><a id="more"></a>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>闭包，是指有权访问另一个函数作用域内的变量的函数</strong>。创建闭包的方式，常见如：在一个函数内部创建另外一个函数，并且将该函数作为返回值，同时该函数还引用了外部函数作用域内的变量。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo1 () &#123;</span><br><span class="line">  var n = 1;</span><br><span class="line">  function foo2 () &#123;</span><br><span class="line">    alert(n)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return foo2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = foo1();</span><br><span class="line">f();  // 1</span><br></pre></td></tr></table></figure>
<h3 id="更广泛的含义"><a href="#更广泛的含义" class="headerlink" title="更广泛的含义"></a>更广泛的含义</h3><p><strong>如果一个函数访问了此函数的父级或父级以上的作用域变量，该函数就可以称之为闭包</strong>。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var num = 1;</span><br><span class="line">(function(i) &#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">&#125;)(num)</span><br></pre></td></tr></table></figure>
<h2 id="闭包产生的原因"><a href="#闭包产生的原因" class="headerlink" title="闭包产生的原因"></a>闭包产生的原因</h2><p>在函数作用域外无法读取函数作用域内的变量，但是借助JS作用域链，函数内部的函数可以访问外层函数的变量。根据这一特性，就可以在函数内部创建并返回一个函数，将函数内部和函数外部作用域连接起来，由此便产生了闭包。</p>
<h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><p>闭包可以让函数外部访问函数内局部作用域的变量，并且可以让该变量始终保存在内存中， 例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn () &#123;</span><br><span class="line">  var num = 3;</span><br><span class="line">  function fn1 () &#123;</span><br><span class="line">    alert(++num);</span><br><span class="line">  &#125;</span><br><span class="line">  return fn1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn2 = fn();</span><br><span class="line">fn2() // 4</span><br><span class="line">fn2() // 5</span><br></pre></td></tr></table></figure></p>
<p>根据这一特性，可以解决实际场景中遇到的以下问题：</p>
<ul>
<li><p>引入的全局变量太多，极易产生全局变量命名冲突<br>例如：（Jquery）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;(function($)&#123;</span><br><span class="line">  // 内部实现</span><br><span class="line">&#125;)(Jquery)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在开发JS插件时，为了保护插件内部变量不被改变<br>例如二（防止私有变量被污染）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const CHANGE_FONT_SIZE=&apos;CHANGE_FONT_SIZE&apos;;</span><br><span class="line"></span><br><span class="line">// 设置一个闭包，把变量保护起来，通过返回值调用</span><br><span class="line">function createStore() &#123;</span><br><span class="line">  let appState=&#123;</span><br><span class="line">    fontSize: &apos;26px&apos;,</span><br><span class="line">    color: &apos;red&apos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 保护变量被修改，深克隆</span><br><span class="line">  let getter=()=&gt;JSON.parse(JSON.stringify(appState));</span><br><span class="line"></span><br><span class="line">  // 改变变量的方法，action代表一个命令对象，就是一个普通的js对象，起码需要一个字段控制命令类型type</span><br><span class="line">  let setter=(action)=&gt;&#123;</span><br><span class="line">    switch(action.type)&#123;</span><br><span class="line">      case CHANGE_FONT_SIZE:</span><br><span class="line">        appState.fontSize = action.fontSize;</span><br><span class="line">      default:</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //返回出去的修改和取值的接口</span><br><span class="line">  return&#123;</span><br><span class="line">    getter,</span><br><span class="line">    setter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let store=createStore();</span><br><span class="line"></span><br><span class="line">// 取值函数</span><br><span class="line">store.getter().fontSize;</span><br><span class="line"></span><br><span class="line">// 修改函数</span><br><span class="line">store.setter(&#123;type:CHANGE_FONT_SIZE, fontSize: &apos;30px&apos;&#125;);</span><br></pre></td></tr></table></figure>
<p>如果需要对重要参数防止被篡改，可使用闭包规定变量的getter和setter<br>以上示例参考，<a href="https://www.cnblogs.com/GoCircle/p/9804106.html" target="_blank" rel="noopener">https://www.cnblogs.com/GoCircle/p/9804106.html</a></p>
<p>例如三（利用闭包来完成对象的继承，做到函数的私有性和公开性）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  // Person模块</span><br><span class="line">  var Person = &#123;</span><br><span class="line">    // 数据部分</span><br><span class="line">    data: &#123;</span><br><span class="line">      name: &quot;&quot;,</span><br><span class="line">      age: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 操作部分</span><br><span class="line">    opt:&#123;</span><br><span class="line">      setName:function(name)&#123;</span><br><span class="line">        Person.data.name=name;     </span><br><span class="line">      &#125;,</span><br><span class="line">      setAge:function(age)&#123;</span><br><span class="line">        Person.data.age=age;</span><br><span class="line">      &#125;,</span><br><span class="line">      getName:function()&#123;</span><br><span class="line">        return Person.data.name; </span><br><span class="line">      &#125;,</span><br><span class="line">      getAge:function()&#123;</span><br><span class="line">        return Person.data.age; </span><br><span class="line">      &#125;,</span><br><span class="line">      init:function(name,age)&#123;</span><br><span class="line">        Person.opt.setName(name);</span><br><span class="line">        Person.opt.setAge(age);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 公开的API</span><br><span class="line">    openAPI:function()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        init:Person.opt.init,</span><br><span class="line">        getName:Person.opt.getName,</span><br><span class="line">        getAge:Person.opt.getAge</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  window.Person = Person;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">var p = window.Person.openAPI();</span><br><span class="line">p.init(&quot;wx&quot;, &quot;20&quot;);</span><br><span class="line">alert(p.getName());</span><br><span class="line">alert(p.getAge());</span><br></pre></td></tr></table></figure>
<p>简单说一下jQuery的源码，其实整个jQuery其实就是一个自调函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(window)&#123;</span><br><span class="line">  // jQuery是一个函数，一个对象，一个构造器函数</span><br><span class="line">  var jQuery = function( selector, context ) &#123;</span><br><span class="line">    return new jQuery.fn.init( selector, context );</span><br><span class="line">  &#125;,</span><br><span class="line">  // 定义了jQuery的prototype的内容</span><br><span class="line">  // fn = prototype</span><br><span class="line">  // 加在jQuery的prototype上的方法可以通过选择器创建出来的对象调用</span><br><span class="line">  // 对象方法</span><br><span class="line">  jQuery.fn = jQuery.prototype = &#123;        </span><br><span class="line">    ready: function()&#123;&#125;,</span><br><span class="line">    each: function()&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // post方法和extend方法直接加在了jQuery对象上 </span><br><span class="line">  // 全局方法    </span><br><span class="line">  jQuery.post = function()&#123;&#125;,</span><br><span class="line">  jQuery.extend = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  // 程序员在用jQuery的时候，是window的一个属性</span><br><span class="line">  //jQuery = $</span><br><span class="line">  window.jQuery = window.$ = jQuery;</span><br><span class="line">  $.fn = jQuery.prototype = window.$.prototype = window.$.fn = window.jQuery.fn = window.jQuery.prototype</span><br><span class="line"></span><br><span class="line">  // 加在jQuery的prototype上的方法和加在jQuery对象上的方法称为jQuery的插件开发</span><br><span class="line">&#125;)(window);</span><br><span class="line"></span><br><span class="line">  window.jQuery.fn=$.prototype=window.$.fn=jQuery.prototype=window.jQuery.prototype</span><br></pre></td></tr></table></figure>
<p>以上示例参考，<a href="https://blog.csdn.net/canot/article/details/50760804" target="_blank" rel="noopener">https://blog.csdn.net/canot/article/details/50760804</a></p>
<h2 id="闭包的副作用"><a href="#闭包的副作用" class="headerlink" title="闭包的副作用"></a>闭包的副作用</h2></li>
<li>内存泄漏<br>如上例fn，fn1作为fn的返回值，形成闭包。fn1被赋值给全局变量fn2，导致fn1始终存在内存中，而fn1引用了父函数fn内的变量num，因此num也会一直在内存中，无法被垃圾回收机制（GC）回收。</li>
</ul>
<h2 id="闭包相关考题"><a href="#闭包相关考题" class="headerlink" title="闭包相关考题"></a>闭包相关考题</h2><ul>
<li><p>考点一：闭包函数调用时，this指向全局window</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 例①</span><br><span class="line">var name = &quot;The Window&quot;;</span><br><span class="line">　var object = &#123;</span><br><span class="line">　　name : &quot;My Object&quot;,</span><br><span class="line">　　getNameFunc : function()&#123;</span><br><span class="line">　　  return function()&#123;</span><br><span class="line">　　　   return this.name;</span><br><span class="line">　　　&#125;;</span><br><span class="line">　　&#125;</span><br><span class="line">　&#125;;</span><br><span class="line"></span><br><span class="line">　alert(object.getNameFunc()());  // The Window</span><br><span class="line"></span><br><span class="line">// 例②</span><br><span class="line">var name = &quot;The Window&quot;;</span><br><span class="line">　var object = &#123;</span><br><span class="line">　　name : &quot;My Object&quot;,</span><br><span class="line">　　getNameFunc : function()&#123;</span><br><span class="line">    var that = this;</span><br><span class="line">　　   return function()&#123;</span><br><span class="line">　　　   return that.name;</span><br><span class="line">　　　 &#125;;</span><br><span class="line">　　&#125;</span><br><span class="line">　&#125;;</span><br><span class="line"></span><br><span class="line">　alert(object.getNameFunc()());  // My Object</span><br></pre></td></tr></table></figure>
<p>题目引用自，<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
</search>
