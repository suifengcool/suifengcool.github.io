<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6中 export default 和 export 区别</title>
    <url>/2017/12/08/ES6-export-default-%E5%92%8C-export-%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>es6渐入主流，export default 和 export经常使用，但是偶尔也会采坑，难得今天公司网络故障，没法做事，正好可以写点心得，避免后面遗忘。</p>
</blockquote>
<ul>
<li>export：使用命名导出</li>
<li>export default：使用默认导出</li>
</ul>
<a id="more"></a>
<h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul>
<li>1、 export 与 export default 均可用于导出常量、函数、文件、模块等；</li>
<li>2、均可以在其他模块和文件使用import的方式进行导入使用；</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>1、通过export方式导出，在导入时需以对象方式进行导入，即加上{xxx}，但是export default不需要；</li>
<li>2、 在一个导出文件或模块中，export可以有很多个，但是export default 只能有一个。</li>
<li>3、 使用export default进行导出，导入时可以使用任意变量名称</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.使用<span class="built_in">export</span>导出</span><br><span class="line"></span><br><span class="line">①方式一</span><br><span class="line">// utils.js 导出文件</span><br><span class="line"><span class="built_in">export</span> const setCookie = (name, value, time) =&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> days = time || 7;    // 默认保存7天</span><br><span class="line">    <span class="built_in">let</span> exp = new Date();</span><br><span class="line">    const PATH = location.pathname.split(<span class="string">'/'</span>)[1];</span><br><span class="line">    <span class="built_in">let</span> _path = (PATH.length == 0 || PATH.indexOf(<span class="string">'.'</span>) != -1) ? <span class="string">'/'</span> : PATH;</span><br><span class="line">    exp.setTime(exp.getTime() + days * 24 * 60 * 60 * 1000);</span><br><span class="line">    document.cookie = `<span class="variable">$&#123;name&#125;</span>=<span class="variable">$&#123;escape(value)&#125;</span>;path=<span class="variable">$&#123;_path&#125;</span>;expires=<span class="variable">$&#123;exp.toGMTString()&#125;</span>`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> getCookie(name)&#123;</span><br><span class="line">    <span class="built_in">let</span> arr, reg = new RegExp(<span class="string">"(^| )"</span> + name + <span class="string">"=([^;]*)(;|$)"</span>)</span><br><span class="line">    <span class="keyword">if</span> (arr = document.cookie.match(reg))</span><br><span class="line">        <span class="built_in">return</span> unescape(arr[2]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//b.js 导入文件</span><br><span class="line">import &#123; setCookie, getCookie &#125; from <span class="string">'./utils'</span>; //也可以分开写两次，导入的时候带花括号</span><br><span class="line"></span><br><span class="line">②方式二</span><br><span class="line">// foo.js 导出文件</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> foo2(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> x * x * x;</span><br><span class="line">&#125;</span><br><span class="line">const foo2 = Math.floor(Math.random()*9 + 3);</span><br><span class="line"><span class="built_in">export</span> &#123; foo1,foo2 &#125;;</span><br><span class="line"></span><br><span class="line">// use.js 导入文件</span><br><span class="line">import &#123; foo1, foo2 &#125; from <span class="string">'foo.js'</span>;</span><br><span class="line">console.log(foo1(3)); // 27</span><br><span class="line">console.log(foo2);    // 3-12之间随机数</span><br><span class="line"></span><br><span class="line">2.使用<span class="built_in">export</span> default导出</span><br><span class="line">// utils.js</span><br><span class="line">const unique = (a) =&gt; &#123;</span><br><span class="line">    var <span class="built_in">hash</span> = &#123;&#125;,</span><br><span class="line">        len = a.length,</span><br><span class="line">        arr = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">hash</span>[a[i]]) &#123;</span><br><span class="line">            <span class="built_in">hash</span>[a[i]] = <span class="literal">true</span>;</span><br><span class="line">            arr.push(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default unique;</span><br><span class="line"></span><br><span class="line">//b.js 导入文件</span><br><span class="line">import unique from <span class="string">'./utils'</span>; //注意，导入的时候没有花括号</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 数组map()方法到底会不会改变原数组</title>
    <url>/2018/01/22/JS-%E6%95%B0%E7%BB%84map-%E6%96%B9%E6%B3%95%E5%88%B0%E5%BA%95%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>　　之前写过关于js数组map()的一篇文章，当时的结论是map()会改变原数组，后来仔细想了一下，其实这个结论很不严谨。那到底结论如何呢，先不慌，看以下两个示例：<br>　　<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr1 = [<span class="string">'xugang'</span>,<span class="string">'wangran'</span>]</span><br><span class="line">arr1.map((item,index)=&gt;&#123;</span><br><span class="line">	<span class="built_in">return</span> item += <span class="string">'good'</span></span><br><span class="line">&#125;)</span><br><span class="line">arr1 //arr1 = [<span class="string">'xugang'</span>,<span class="string">'wangran'</span>]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr2 = [&#123;</span><br><span class="line">	name: <span class="string">'xugang'</span>,</span><br><span class="line">	age: 29</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	name: <span class="string">'wangran'</span>,</span><br><span class="line">	age: 28</span><br><span class="line">&#125;]</span><br><span class="line">arr2.map((item,index)=&gt;&#123;</span><br><span class="line">	<span class="built_in">return</span> item.age += 1</span><br><span class="line">&#125;)</span><br><span class="line">arr2 //arr2 = [&#123;name:<span class="string">'xugang'</span>,age:30&#125;,&#123;name: <span class="string">'wangran'</span>,age:29&#125;]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>　　那么问题来了，为什么例子2原数组改变了，但例子1却没有更改呢？其实，这锅真不该map()来背！<br>　　我们知道，js数据类型分为基本数据类型和引用数据类型两种。其中，基本数据包括有Number、String、Null、Undefined、Boolean,引用数据类型包括有Object、Function、Awrry等。基本数据类型是按值传递，而引用数据类型是按引用传值。如下：
　　</p>
<h3 id="基本数据类型-amp-引用数据类型"><a href="#基本数据类型-amp-引用数据类型" class="headerlink" title="基本数据类型&amp;引用数据类型"></a>基本数据类型&amp;引用数据类型</h3><h5 id="1、基本数据类型："><a href="#1、基本数据类型：" class="headerlink" title="1、基本数据类型："></a>1、基本数据类型：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> a = <span class="string">'1'</span>;</span><br><span class="line"><span class="built_in">let</span> b = a;</span><br><span class="line">b = <span class="string">'2'</span>;</span><br><span class="line">a   // a = <span class="string">'1'</span></span><br></pre></td></tr></table></figure>
<p>　　本例中，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。基本数据类型都是保存在栈内存。</p>
<p><img src="https://pic002.cnblogs.com/images/2012/327530/2012062912181127.jpg" alt></p>
<h5 id="2、引用数据类型："><a href="#2、引用数据类型：" class="headerlink" title="2、引用数据类型："></a>2、引用数据类型：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var obj1 = new Object();</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj2.name = <span class="string">"xugang"</span>;</span><br><span class="line">console.log(obj1.name); // <span class="string">'xugang'</span></span><br></pre></td></tr></table></figure>
<p>　　本例中，这两个引用数据类型指向了同一个堆内存对象。obj1赋值给obj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2，但是实际上他们共同指向了同一个堆内存对象。实际上改变的是堆内存对象。<br>　　<br><img src="https://pic002.cnblogs.com/images/2012/327530/2012062914380085.jpg" alt></p>
<h5 id="3、总结两种数据类型区别点："><a href="#3、总结两种数据类型区别点：" class="headerlink" title="3、总结两种数据类型区别点："></a>3、总结两种数据类型区别点：</h5><ul>
<li>a、声明变量时不同的内存分配<ul>
<li>1、基本数据类型：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。</li>
<li>2、引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。</li>
</ul>
</li>
<li>b、不同的内存分配机制也带来了不同的访问机制<ul>
<li>1、在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。</li>
<li>2、而原始类型的值则是可以直接访问到的。</li>
</ul>
</li>
<li>c、 复制变量时的不同<ul>
<li>1、原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。</li>
<li>2、引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针</li>
</ul>
</li>
<li>d、 参数传递的不同（把实参复制给形参的过程）<br>  首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 <ul>
<li>1、原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。</li>
<li>2、引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数据类型</title>
    <url>/2020/11/22/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>一步一步重温 <strong>JavaScript</strong> 基础系列。<br>本章节将会理解JS的数据类型，以及如何检测JS数据类型。</p>
</blockquote>
<h2 id="1-JavaScript-数据类型"><a href="#1-JavaScript-数据类型" class="headerlink" title="1 JavaScript 数据类型"></a>1 JavaScript 数据类型</h2><ul>
<li>六种基本数据类型：Null、Undefined、Boolean、Number、String 和 Symbol（es6）</li>
<li>一种引用数据类型：Object</li>
</ul>
<a id="more"></a>
<h3 id="1-1-Null-和-Undefined-区别"><a href="#1-1-Null-和-Undefined-区别" class="headerlink" title="1.1 Null 和 Undefined 区别"></a>1.1 Null 和 Undefined 区别</h3><ul>
<li>Null 是指变量未声明， 或者声明但未赋值</li>
<li>Undefined 是指变量声明且赋值为空</li>
</ul>
<p>一般会在以下两种情况下，将变量赋值为null:</p>
<ol>
<li>当一个变量准备用来存放一个对象，一开始又没有存放时，可以先赋值为null</li>
<li>解除引用，比如释放定时器等（注：解除一个值的引用并不意味着自动回收该值所占用的内存，让变量脱离执行环境，以便垃圾收集器在下次运行时将其回收）</li>
</ol>
<h3 id="1-2-Symbol"><a href="#1-2-Symbol" class="headerlink" title="1.2 Symbol"></a>1.2 Symbol</h3><p>一种类似于字符串的数据类型，表示独一无二的值，用来防止属性名的冲突</p>
<h2 id="3-检测数据类型"><a href="#3-检测数据类型" class="headerlink" title="3 检测数据类型"></a>3 检测数据类型</h2><p>① typeof 返回该种数据类型的字符串形式，如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof 1          // &quot;number&quot;</span><br><span class="line">typeof(typeof 1)  // &quot;string&quot;</span><br><span class="line">  </span><br><span class="line">typeof null       // &quot;object&quot;, null表示一个空对象指针，故返回&quot;object&quot;</span><br><span class="line">typeof foo        // &quot;function&quot;, function也是对象，理论上应返回&quot;object&quot;, 但是函数有其特殊属性，有必要进行区分，故返回 &quot;function&quot;</span><br></pre></td></tr></table></figure>
<p>  <code>typeof</code> 只能用来检测除 <code>null</code> 类型外的其它基本类型，另外能够检测出引用类型中 <code>function</code> 数据类型。</p>
<p>② instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上， 如下：<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function A () &#123;&#125;</span><br><span class="line">function B () &#123;&#125;</span><br><span class="line"></span><br><span class="line">var a = new A()</span><br><span class="line">var B = new B()</span><br><span class="line"></span><br><span class="line">a instanceof A    // true, 因为Object.getPrototypeOf(a).__proto__ === A.prototype</span><br><span class="line">a instanceof B    // false</span><br></pre></td></tr></table></figure></p>
<p>  <code>instanceof</code>只能够检测出引用类型的变量，是否在右侧构造函数的原型链上，并且由于所有引用类型都是Object的实例，所以在检测一个引用类型的变量 和 Object构造函数时，instanceof操作符始终会返回true。</p>
<p>③ Object.prototype.toString， 能够检测出所有的数据类型， 如下：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.prototype.toString.call(1)    // &quot;[object Number]&quot;</span><br><span class="line">Object.prototype.toString.call(&apos;1&apos;)  // &quot;[object String]&quot;</span><br><span class="line">Object.prototype.toString.call(null) // &quot;[object Null]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)   // &quot;[object Object]&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>综上所述，JS检测数据，最优方法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @desc   数据类型检测</span><br><span class="line"> * @params val &#123; any &#125; 待检测的数据</span><br><span class="line"> * @return &#123; String &#125; 类型字符串 </span><br><span class="line"> */</span><br><span class="line">function type(val) &#123;     </span><br><span class="line">	return typeof val !== &quot;object&quot; </span><br><span class="line">		? typeof val </span><br><span class="line">		: Object.prototype.toString.call(val).slice(8, -1).toLowerCase(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 数组去重</title>
    <url>/2018/02/06/JS-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<ul>
<li><p>1、 数组元素为基本数据类型</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">const unique = (arrwy) =&gt; &#123;</span><br><span class="line">       <span class="built_in">let</span> obj = &#123;&#125;, arr = [];</span><br><span class="line">    arrwy.forEach((ele, index) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj[ele])&#123;</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            obj[ele] = <span class="string">'1'</span>;</span><br><span class="line">            arr.push(ele)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <a id="more"></a>
<p>  原理：new一个空对象和一个空数组，遍历原数组，将原数组每一项作为空对象的新增属性，循环过程中，如果目标对象已经包含该属性，则return，否则给该属性取值为1，并把该属性push进空数组。此空数组即为原数组去重后的数组。</p>
</li>
<li><p>2、 数组元素为基本数据类型（es6 Set）</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[...new Set([1,<span class="string">'1'</span>,<span class="string">'1'</span>,2,1])]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>3、 数组元素为对象，且去重标准为其中的某一个属性</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	const unique = (arrwy,key) =&gt; &#123;</span><br><span class="line">	    <span class="built_in">let</span> obj = &#123;&#125;, arr = [];</span><br><span class="line">	    arrwy.forEach((ele, index) =&gt; &#123;</span><br><span class="line">	        <span class="keyword">if</span>(obj[ele.key])&#123;</span><br><span class="line">	            <span class="built_in">return</span></span><br><span class="line">	        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	            obj[ele.key] = <span class="string">'1'</span>;</span><br><span class="line">	            arr.push(ele)</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;);</span><br><span class="line">	    <span class="built_in">return</span> arr;</span><br><span class="line">	&#125;</span><br><span class="line">	```	</span><br><span class="line">	</span><br><span class="line">	原理：new一个空对象和一个空数组，遍历原数组，将原数组每一项的指定属性的属性值作为空对象的新增属性，循环过程中，如果目标对象已经包含该属性，则<span class="built_in">return</span>，否则给该属性取值为1，并把该属性push进空数组。此空数组即为原数组去重后的数组。</span><br><span class="line">	</span><br><span class="line">* 4、 数组元素为对象，且去重标准为其中的某几个属性</span><br><span class="line"></span><br><span class="line">	``` bash</span><br><span class="line">		//将对象元素转换成字符串以作比较  </span><br><span class="line">		<span class="keyword">function</span> obj2key(obj, keys)&#123;  </span><br><span class="line">		    var n = keys.length,  </span><br><span class="line">		        key = [];  </span><br><span class="line">		    <span class="keyword">while</span>(n--)&#123;  </span><br><span class="line">		        key.push(obj[keys[n]]);  </span><br><span class="line">		    &#125;  </span><br><span class="line">		    <span class="built_in">return</span> key.join(<span class="string">'|'</span>);  </span><br><span class="line">		&#125;  </span><br><span class="line">		</span><br><span class="line">		//去重操作  </span><br><span class="line">		<span class="keyword">function</span> uniqeByKeys(array,keys)&#123;  </span><br><span class="line">		    var arr = [];  </span><br><span class="line">		    var <span class="built_in">hash</span> = &#123;&#125;;  </span><br><span class="line">		    <span class="keyword">for</span> (var i = 0, j = array.length; i &lt; j; i++) &#123;  </span><br><span class="line">		        var k = obj2key(array[i], keys);  </span><br><span class="line">		        <span class="keyword">if</span> (!(k <span class="keyword">in</span> <span class="built_in">hash</span>)) &#123;  </span><br><span class="line">		            <span class="built_in">hash</span>[k] = <span class="literal">true</span>;  </span><br><span class="line">		            arr .push(array[i]);  </span><br><span class="line">		        &#125;  </span><br><span class="line">		    &#125;  </span><br><span class="line">		    <span class="built_in">return</span> arr ;  </span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="built_in">let</span> arr = [&#123;</span><br><span class="line">			name: <span class="string">'aaa'</span>,</span><br><span class="line">			<span class="built_in">type</span>: <span class="string">'shop'</span></span><br><span class="line">		&#125;,&#123;</span><br><span class="line">			name: <span class="string">'bbb'</span>,</span><br><span class="line">			<span class="built_in">type</span>: <span class="string">'msg'</span></span><br><span class="line">		&#125;,&#123;</span><br><span class="line">			name: <span class="string">'bbb'</span>,</span><br><span class="line">			<span class="built_in">type</span>: <span class="string">'msg'</span></span><br><span class="line">		&#125;];</span><br><span class="line">		arr = uniqeByKeys(arr,[<span class="string">'name'</span>,<span class="string">'type'</span>]);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>css使用技巧（1）-元素居中</title>
    <url>/2018/02/08/css%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%881%EF%BC%89-%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<p>css元素居中是个永恒的话题，随着前端技术的进一步发展，实现方式也是愈来愈多，这里讲几个实用且高效的方式：</p>
<h3 id="1、-水平居中"><a href="#1、-水平居中" class="headerlink" title="1、 水平居中"></a>1、 水平居中</h3><ul>
<li><p>1、 行内（内联）元素： text-align: center;</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">	text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>2、 块级元素：margin: xpx auto; （子元素需设置宽度）</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.child&#123;</span><br><span class="line">	width: 200px;</span><br><span class="line">	margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>3、 flex布局： 子元素为内联元素</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	.parent&#123;</span><br><span class="line">		display: flex;</span><br><span class="line">		justify-content: center;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	```	</span><br><span class="line">	</span><br><span class="line">* 4、 flex布局： 子元素为块级元素（子元素无需设置宽度）</span><br><span class="line"></span><br><span class="line">	``` bash</span><br><span class="line">	</span><br><span class="line">	.parent&#123;</span><br><span class="line">		display: flex;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.child&#123;</span><br><span class="line">		margin: 10px auto;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	```		</span><br><span class="line">	</span><br><span class="line"><span class="comment">### 2、 垂直居中</span></span><br><span class="line">	</span><br><span class="line">* 1、 行内（内联）元素： height = line-height</span><br><span class="line"></span><br><span class="line">	``` bash</span><br><span class="line">	</span><br><span class="line">	.parent&#123;</span><br><span class="line">		height: 200px;</span><br><span class="line">		line-height: 200px;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>2、 块级元素: 绝对定位（子元素尺寸需确定, margin负值实现位移）    </p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.parent&#123;</span><br><span class="line">	position: relative;</span><br><span class="line">	height: 300px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.child&#123;</span><br><span class="line">	width: 50px;</span><br><span class="line">	height: 40px;</span><br><span class="line">	position: absolute;</span><br><span class="line">	left: 50%;</span><br><span class="line">	right: 50%;</span><br><span class="line">	margin-top: -20px;</span><br><span class="line">	margin-right: -25px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、 块级元素: 绝对定位（子元素尺寸需确定, margin: auto）    </p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	.parent&#123;</span><br><span class="line">		position: relative;</span><br><span class="line">		height: 300px;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.child&#123;</span><br><span class="line">		width: 50px;</span><br><span class="line">		height: 50px;</span><br><span class="line">		position: absolute;</span><br><span class="line">		top: 0;</span><br><span class="line">		right: 0;</span><br><span class="line">		bottom: 0;</span><br><span class="line">		left: 0;</span><br><span class="line">		margin: auto;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	```		</span><br><span class="line">	</span><br><span class="line">* 4、 块级元素: 绝对定位（子元素尺寸无需确定, transform位移）	</span><br><span class="line"></span><br><span class="line">	``` bash</span><br><span class="line">	</span><br><span class="line">	.parent&#123;</span><br><span class="line">		position: relative;</span><br><span class="line">		height: 300px;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.child&#123;</span><br><span class="line">		position: absolute;</span><br><span class="line">		left: 50%;</span><br><span class="line">		right: 50%;</span><br><span class="line">		transform: translate(-50%,-50%);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>5、 flex布局，子元素为块级元素，父元素display: flex; 子元素margin: auto;</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	.parent&#123;</span><br><span class="line">		display: flex;</span><br><span class="line">		width: 500px;</span><br><span class="line">		height: 500px;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.child&#123;</span><br><span class="line">		margin: auto 10px;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	```	</span><br><span class="line">	</span><br><span class="line">* 6、 flex布局, 子元素为内联元素，父级元素display: flex; </span><br><span class="line"></span><br><span class="line">	``` bash</span><br><span class="line">	</span><br><span class="line">	.parent&#123;</span><br><span class="line">		display: flex;</span><br><span class="line">		width: 500px;</span><br><span class="line">		height: 500px;</span><br><span class="line">		align-items: center;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript执行环境及作用域</title>
    <url>/2020/11/25/Javascript%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<blockquote>
<p>一步一步重温 <strong>JavaScript</strong> 基础系列。<br>本章节将会理解JS的执行环境即执行上下文相关概念，包括变量对象、活动对象、以及两者区别</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>执行环境</strong>（execution context）定义了变量或函数有权访问的其它数据，决定了各自的行为。当JS代码执行的时候，会进入不同的执行环境，这些不同的执行环境就构成了执行环境栈。当执行环境中的代码执行完毕之后，执行环境被销毁，其中的所有变量和函数也随之销毁。执行环境也称之为执行上下文。</p>
<a id="more"></a>
<p>每个执行环境都有三个重要的属性：变量对象（VO）、作用域链（scope chain）以及 this。</p>
<p><img src="/images/执行环境01.jpg" alt="按值传递图解"><br>注：对于VO来说，函数表达式不包含在VO中，没有使用var声明的变量也不包含在VO中，这种方式只是给Global添加了一个属性。</p>
<h2 id="执行上下文类型"><a href="#执行上下文类型" class="headerlink" title="执行上下文类型"></a>执行上下文类型</h2><ul>
<li><strong>全局执行上下文</strong>，只有一个，在浏览器中，通常为windows对象，所有的全局变量和函数都作为window对象的属性和方法存在。对于全局执行环境来说，当关闭网页或浏览器时，该环境被销毁；</li>
<li><strong>局部（函数）执行上下文</strong> ，每个函数都有自己的执行环境，当js执行流进入一个函数时，函数的环境会被推入一个环境栈中，当函数执行完毕后，栈将其环境弹出，该环境随即被销毁；</li>
<li><strong>Eval上下文</strong>，运行在 eval 函数中的代码，由于eval 的性能低、不易调试且有安全问题，一般禁止使用。 </li>
</ul>
<h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也称调用栈，具有“后进先出”（LIFO）原则，用于储存代码的执行期间创建的所有执行上下文。</p>
<p>首次运行js代码时，会创建一个全局执行上下文，并被push至执行栈首位。当顺序执行函数调用时，引擎都会为执行函数创建一个执行上下文，并push至当前执行栈的栈顶。</p>
<p>当函数调用完成后，其执行上下文就会从执行栈顶被推出（这是理想情况，闭包则不会，后续深入理解）。</p>
<h2 id="执行上下文的生命周期"><a href="#执行上下文的生命周期" class="headerlink" title="执行上下文的生命周期"></a>执行上下文的生命周期</h2><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><ul>
<li>创建变量环境（VO）<br>  ① 函数环境会初始化创建 Arguments对象（并赋值）<br>  ② 函数声明（并赋值）<br>  ③ 变量声明，函数表达式声明（未赋值）</li>
<li>确定this指向（this由调用者确定）</li>
<li>确定作用域（词法环境决定，哪里声明定义，就在哪里确定）</li>
</ul>
<h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><ul>
<li>变量对象赋值<br>  ① 变量赋值<br>  ② 函数表达式赋值</li>
<li>调用函数</li>
<li>顺序执行其它代码</li>
</ul>
<p>代码解释如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 第一步： </span><br><span class="line"> * 当程序加载时全局执行环境就被创建，并且创建一个VO对象来保存当前全局变量与全局函数，</span><br><span class="line"> * 在刚刚创建的VO对象中，变量的值被保存为undefined，函数属性的值保存为对应的函数体 </span><br><span class="line"> * 全局执行环境 ==&gt; VO = &#123;</span><br><span class="line"> 		a: undefined,</span><br><span class="line"> 		fn1: fn1函数体,</span><br><span class="line"> 		fn3: fn3函数体</span><br><span class="line">	&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">var a = &quot;global&quot;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 第二步： </span><br><span class="line"> * 当程序执行到此处时，变量a执行赋值操作，VO对象中的属性g的值发生变化</span><br><span class="line"> * 全局执行环境 ==&gt; VO = &#123;</span><br><span class="line"> 		a: &quot;global&quot;,</span><br><span class="line"> 		fn1: fn1函数体,</span><br><span class="line"> 		fn3: fn3函数体</span><br><span class="line">	&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">function fn3(num)&#123;</span><br><span class="line">   console.log(num);  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function fn1(num1,num2)&#123;</span><br><span class="line">	var b = num1 + num2;</span><br><span class="line"></span><br><span class="line">	function fn2(num3)&#123;</span><br><span class="line">		var c = ++num3;</span><br><span class="line">		fn3(c);</span><br><span class="line">		/*第五步*/</span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	fn2(b);</span><br><span class="line">	/*第四步*/</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fn1(2,5);</span><br><span class="line">/*</span><br><span class="line"> * 第三步： </span><br><span class="line"> * 发现fn1函数被调用并传参，那么就进入fn1函数内部并创建fn1执行环境，由于在函数执行环境中</span><br><span class="line"> * VO是无法直接访问的，所以当fn1环境被创建时，会同时创建一个AO对象，其默认带有一个arg属性</span><br><span class="line"> * 这个属性保存了函数调用时传入的实参，该AO对象同时也会保存fn1函数的形参num1,num2并赋值，</span><br><span class="line"> * 保存局部变量b，b的值为undefined， 函数属性的值保存为对应的函数体 </span><br><span class="line"> * fn1执行环境 ==&gt; AO = &#123;</span><br><span class="line"> 		arguments: [2,5],</span><br><span class="line"> 		num1: 2, </span><br><span class="line"> 		num2: 5, </span><br><span class="line"> 		b= undefined,</span><br><span class="line"> 		fn2: fn2函数体</span><br><span class="line">	&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<p><strong>总结</strong>：<br>① 当程序开始执行，自动创建一个全局执行环境和一个VO对象；<br>② 当函数被调用时，在函数中会创建一个函数执行环境和一个AO对象，AO与VO功能相同；<br>③ 当函数执行环境被创建后，js会创建一个执行环境栈，将当前执行环境入栈，当该函数执行结束之后，其对应的执行环境会从栈中抛出并销毁。</p>
<h2 id="变量对象（AO）和活动对象（VO）"><a href="#变量对象（AO）和活动对象（VO）" class="headerlink" title="变量对象（AO）和活动对象（VO）"></a>变量对象（AO）和活动对象（VO）</h2><h3 id="变量对象（Variable-Object，简称VO）"><a href="#变量对象（Variable-Object，简称VO）" class="headerlink" title="变量对象（Variable Object，简称VO）"></a>变量对象（Variable Object，简称VO）</h3><p>每个执行环境都有一个与之关联的变量对象，用来保存环境中定义的所有变量和函数。一般来说，VO对象包含变量、形参和函数声明。</p>
<h3 id="活动对象（Activation-Object，简称AO）"><a href="#活动对象（Activation-Object，简称AO）" class="headerlink" title="活动对象（Activation Object，简称AO）"></a>活动对象（Activation Object，简称AO）</h3><p>当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象(AO)，这时候活动对象上的各种属性才能被访问。</p>
<p>函数的执行环境是在调用时创建的，在创建函数执行环境的同时会对应创建一个带有arguments属性的AO对象，该对象将代替VO对象来保存当前函数环境中的变量、参数和函数，所以在函数执行环境中VO就是AO。</p>
<h3 id="VO和AO的区别"><a href="#VO和AO的区别" class="headerlink" title="VO和AO的区别"></a>VO和AO的区别</h3><p>① 非函数执行环境对应创建一个VO对象；<br>② 函数执行环境对应创建一个默认带有arguments属性的AO对象；<br>③ AO是函数执行环境下的VO，两者的作用是相同的。</p>
<h2 id="作用域-和-作用域链"><a href="#作用域-和-作用域链" class="headerlink" title="作用域 和 作用域链"></a>作用域 和 作用域链</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><strong>作用域</strong>就是变量和函数的可访问范围。</p>
<ul>
<li><strong>全局作用域</strong>，在代码中任何地方都能访问到的对象拥有全局作用域<br>  ① window 对象的内置属性都拥有全局作用域；<br>  ② 定义在最外层的函数和变量拥有全局作用域；<br>  ③ 所有未定义但直接赋值的变量也拥有全局作用域。</li>
<li><strong>局部作用域</strong>，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所以也称为函数作用域</li>
<li><p><strong>块级作用域</strong>，意思是由花括号封闭的代码块有自己的作用域<br>  ① <strong>没有块级作用域</strong>，es6之前，js没有块级作用域，由此会产生问题：<strong>在if或者for循环中声明的变量会泄露成全局变量</strong></p>
<p>  代码理解如下：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 例子1：</span><br><span class="line">if(true) &#123;</span><br><span class="line">	var color = &apos;blue&apos;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(color)</span><br><span class="line">// 在if语句中声明的变量，会被添加至if语句当前的执行环境中（此时为全局作用域）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 例子2：</span><br><span class="line">for(var i=0;i &lt; 10; i ++)&#123;</span><br><span class="line">	// doSomeThing(i)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;i:&apos;, i)</span><br><span class="line">// 结果会返回10，对于有块级作用域的语言来说，for语句内定义的变量，只会存在于循环体内，而es6之前，js没有块级作用域，由for语句定义的变量i，即使for循环结束后，也依旧存在于for语句所在的执行环境中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 例子3：</span><br><span class="line">var temp = &apos;green&apos;;</span><br><span class="line">function foo() &#123;</span><br><span class="line">	console.log(temp);</span><br><span class="line">	if(false) &#123;</span><br><span class="line">		var temp = &apos;blue&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">// 结果打印为&apos;undefined&apos;。虽然按照我们常规理解，由于if语句并不会被执行，在foo函数作用域内，左右没有temp变量的值， 此时向上查找到全局作用域确定temp变量的值为green。但是由于js没有块级作用域，if语句中声明的变量，会被添加至if语句所在的执行环境中，所以在变量提升的前提下，此时temp值为 &apos;undefined&apos;。</span><br></pre></td></tr></table></figure>
<p>  ② <strong>es6块级块级作用域</strong></p>
<p>  ③ <strong>模仿块级作用域</strong>，ES6以前变量的作用域是函数范围，有时在函数内局部需要一些临时变量，因为没有块级作用域，所以就会将局部代码封装到IIEF（立即执行函数）中。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 立即执行函数</span><br><span class="line">(function()&#123;</span><br><span class="line">  var temp = &quot;hello world&quot;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// 块级作用域</span><br><span class="line">&#123;</span><br><span class="line">  var temp = &quot;hello world&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  明白了块级作用域，模仿块级作用域，咱们再来道老生常谈的旧菜测试一下：<strong>如何在for循环中，依次打印出 0,1,2 ?</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 方式①  使用匿名函数自执行，模仿块级作用域</span><br><span class="line">for (var i=0; i &lt; 3; i ++) &#123;</span><br><span class="line">  (function (a) &#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式② 使用es6 let，自带块级作用域</span><br><span class="line">for (let i=0; i &lt; 3; i ++) &#123;</span><br><span class="line">  console.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>在确定一个变量的值时，首先会从当前所在的局部作用域内查找，如果找到则停止，否则就会在上级作用域内查找，直到全局作用域。这个逐级向上查找形成的链条，就称之为作用域链。</p>
<p>来道小菜，测试一下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var scope = &quot;global&quot;;</span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(scope);</span><br><span class="line">    var scope = &quot;local&quot;;</span><br><span class="line">    console.log(scope);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">// 打印结果为：&apos;undefined&apos;, &apos;local&apos;</span><br><span class="line">// 在函数foo内部，由于存在变量提升，scope首先会被赋值为&apos;undefined&apos;，也就是说在函数作用域内已经找到scope变量的值，查找结束，所以第一个打印为&apos;undefined&apos;。接着，进行变量重新赋值，所以第二个打印为&apos;local&apos;。当然了，这道题的考点主要在变量提升，咱们接着聊。</span><br></pre></td></tr></table></figure></p>
<h2 id="函数声明，变量声明，函数表达式的优先级"><a href="#函数声明，变量声明，函数表达式的优先级" class="headerlink" title="函数声明，变量声明，函数表达式的优先级"></a>函数声明，变量声明，函数表达式的优先级</h2><ul>
<li>函数声明，如果有同名属性，后面会替换前面</li>
<li>函数声明优先级高于变量声明</li>
<li>函数表达式不会有变量提升</li>
</ul>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>git 常用操作</title>
    <url>/2017/12/13/git-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="一、提交代码"><a href="#一、提交代码" class="headerlink" title="一、提交代码"></a>一、提交代码</h3><h5 id="查看当前目录下更改的文件"><a href="#查看当前目录下更改的文件" class="headerlink" title="查看当前目录下更改的文件"></a>查看当前目录下更改的文件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="查看当前目录下更改文件的更改点"><a href="#查看当前目录下更改文件的更改点" class="headerlink" title="查看当前目录下更改文件的更改点"></a>查看当前目录下更改文件的更改点</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>
<h5 id="添加当前目录下的所有文件到暂存区"><a href="#添加当前目录下的所有文件到暂存区" class="headerlink" title="添加当前目录下的所有文件到暂存区"></a>添加当前目录下的所有文件到暂存区</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<h5 id="将代码从暂存区提交至仓库区"><a href="#将代码从暂存区提交至仓库区" class="headerlink" title="将代码从暂存区提交至仓库区"></a>将代码从暂存区提交至仓库区</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"描述"</span></span><br></pre></td></tr></table></figure>
<h5 id="将远程仓库区代码同步本地"><a href="#将远程仓库区代码同步本地" class="headerlink" title="将远程仓库区代码同步本地"></a>将远程仓库区代码同步本地</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull    或者 git pull origin 远程仓库名</span><br></pre></td></tr></table></figure>
<h5 id="将本地仓库区代码提交至远程仓库"><a href="#将本地仓库区代码提交至远程仓库" class="headerlink" title="将本地仓库区代码提交至远程仓库"></a>将本地仓库区代码提交至远程仓库</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin 远程仓库名    或者 git push</span><br></pre></td></tr></table></figure>
<h3 id="二、撤销操作"><a href="#二、撤销操作" class="headerlink" title="二、撤销操作"></a>二、撤销操作</h3><h5 id="撤销add操作"><a href="#撤销add操作" class="headerlink" title="撤销add操作"></a>撤销add操作</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD .</span><br></pre></td></tr></table></figure>
<h5 id="撤销commit操作"><a href="#撤销commit操作" class="headerlink" title="撤销commit操作"></a>撤销commit操作</h5><ul>
<li>1、找到上次git commit的commit_id</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2、完成撤销,同时将代码恢复到前一commit_id 对应的版本。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure>
<ul>
<li>或者2、完成Commit命令的撤销，但是不对代码修改进行撤销，可以直接通过git commit 重新提交对本地代码的修改。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset commit_id</span><br></pre></td></tr></table></figure>
<h3 id="三、查看、切换、删除、新建分支"><a href="#三、查看、切换、删除、新建分支" class="headerlink" title="三、查看、切换、删除、新建分支"></a>三、查看、切换、删除、新建分支</h3><h5 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<h5 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<h5 id="切换本地分支"><a href="#切换本地分支" class="headerlink" title="切换本地分支"></a>切换本地分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout xxx</span><br></pre></td></tr></table></figure>
<p>注意，每次切换分支，本地当前分支均不得有变动，否则需要先提交，在切换分支</p>
<h5 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -D xxx</span><br></pre></td></tr></table></figure>
<h5 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b xxx origin/master</span><br><span class="line">git push origin xxx</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>这样新建的分支，是从远程matser分支上新建的分支，并且当远程master分支代码更改时，执行git pull，本地代码也会同步远程master上代码更改。由此新建的分支，push代码时需用 git push origin xxx。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -b xxx</span><br><span class="line">git push</span><br><span class="line">git pull origin xxx</span><br></pre></td></tr></table></figure>
<p>需先切换至主分支，比如master上，这样新建的分支，执行git pull origin xxx，本地代码只会同步远程xxx分支上代码更改，不会同步远程master分支的代码。由此新建的分支，push代码时需用 git push 。</p>
<h3 id="四、解决冲突"><a href="#四、解决冲突" class="headerlink" title="四、解决冲突"></a>四、解决冲突</h3><h6 id="提交代码，最好是在gitlab上面合并分支，当提示有代码冲突时，关闭当前合并请求，并使用命令行按如下方式解决冲突。"><a href="#提交代码，最好是在gitlab上面合并分支，当提示有代码冲突时，关闭当前合并请求，并使用命令行按如下方式解决冲突。" class="headerlink" title="提交代码，最好是在gitlab上面合并分支，当提示有代码冲突时，关闭当前合并请求，并使用命令行按如下方式解决冲突。"></a>提交代码，最好是在gitlab上面合并分支，当提示有代码冲突时，关闭当前合并请求，并使用命令行按如下方式解决冲突。</h6><h6 id="主分支master-待合并分支-xugang"><a href="#主分支master-待合并分支-xugang" class="headerlink" title="主分支master,待合并分支 xugang"></a>主分支master,待合并分支 xugang</h6><ul>
<li>1、 git checkout xugang</li>
<li>2、 git pull</li>
<li>3、 git checkout master</li>
<li>4、 git pull</li>
<li>5、 git merge xugang （此时会提示存在冲突文件）</li>
<li>6、 git status         （查看存在冲突的文件）</li>
<li>7、 git diff           （查看冲突详情）</li>
<li>8、 在当前本地分支master上解决冲突，一定要本地运行，确保无误</li>
<li>9、 git push   </li>
<li>10、git checkout xugang   （这一步尤其重要，避免在master上直接更改代码。）</li>
</ul>
<h3 id="五、取消追踪-amp-追踪本地文件更改"><a href="#五、取消追踪-amp-追踪本地文件更改" class="headerlink" title="五、取消追踪&amp; 追踪本地文件更改"></a>五、取消追踪&amp; 追踪本地文件更改</h3><h5 id="取消追踪本地文件更改"><a href="#取消追踪本地文件更改" class="headerlink" title="取消追踪本地文件更改"></a>取消追踪本地文件更改</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git update-index --assume-unchanged src/config/server.json</span><br></pre></td></tr></table></figure>
<p>让git取消对server.json的track。</p>
<h5 id="恢复追踪本地文件更改"><a href="#恢复追踪本地文件更改" class="headerlink" title="恢复追踪本地文件更改"></a>恢复追踪本地文件更改</h5><pre><code>git update-index --no-assume-unchanged src/config/server.json
</code></pre><p>让git能够追踪记录到此文件</p>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/2017/12/21/hexo/</url>
    <content><![CDATA[<h5 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"xxxx"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="Installed-Extension"><a href="#Installed-Extension" class="headerlink" title="Installed Extension"></a>Installed Extension</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h5 id="Clear-Cache"><a href="#Clear-Cache" class="headerlink" title="Clear Cache"></a>Clear Cache</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<h5 id="Generate"><a href="#Generate" class="headerlink" title="Generate"></a>Generate</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<h5 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<h5 id="Simply"><a href="#Simply" class="headerlink" title="Simply"></a>Simply</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<h5 id="Local-debugging"><a href="#Local-debugging" class="headerlink" title="Local debugging"></a>Local debugging</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s -debug</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript面向对象编程</title>
    <url>/2017/10/10/javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>Javascript是一种基于对象的语言，但是，又不是一种真正意义上的面向对象的语言，因为没有class（类）的语法。</p>
<h4 id="一、创建对象"><a href="#一、创建对象" class="headerlink" title="一、创建对象"></a>一、创建对象</h4><p>创建对象就是把属性（property）和方法（method）封装成一个对象，或者从原型对象中实例化一个对象。<br>下面以实例化小狗对象为例，小狗具有名字和品种两个属性。<br><a id="more"></a></p>
<h5 id="1、原始模式"><a href="#1、原始模式" class="headerlink" title="1、原始模式"></a>1、原始模式</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var dog1 = &#123;&#125;;</span><br><span class="line">dog1.name = <span class="string">'二牛'</span>;</span><br><span class="line">dog1.variety = <span class="string">'牛头梗'</span>;</span><br><span class="line"> </span><br><span class="line">var dog2 = &#123;&#125;;</span><br><span class="line">dog2.name = <span class="string">'二狗'</span>;</span><br><span class="line">dog2.variety = <span class="string">'哈士奇'</span>;</span><br></pre></td></tr></table></figure>
<p>这样封装对象虽然简单，但是有两个缺点，一是如果要创建多个实例的话，写起来会比较麻烦，二是这种写法并不能看出实例和原型之间有什么关系。<br>对原始模式进行改进，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Dog(name, variety) &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        variety: variety</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var dog1 = Dog(<span class="string">'二牛'</span>, <span class="string">'牛头梗'</span>);</span><br><span class="line">var dog2 = Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br></pre></td></tr></table></figure>
<p>改进后解决了代码重复的问题，但是dog1和dog2之间并没有内在联系，不是来自于同一个原型对象。</p>
<h5 id="2、构造函数模式"><a href="#2、构造函数模式" class="headerlink" title="2、构造函数模式"></a>2、构造函数模式</h5><p>构造函数，是内部使用了this的函数。通过new构造函数就能生成对象实例，并且this变量会绑定在实例对象上。使用构造函数可以解决从原型对象构建实例的问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Dog(name, variety) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.variety = variety;</span><br><span class="line">&#125;</span><br><span class="line">var dog1 = new Dog(<span class="string">'二牛'</span>, <span class="string">'牛头梗'</span>);</span><br><span class="line">var dog2 = new Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog1.name); // 二牛</span><br><span class="line"><span class="built_in">print</span>(dog2.name); // 二狗</span><br></pre></td></tr></table></figure>
<p>验证实例对象与原型对象之间的关系：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(dog1.cunstructor === Dog); // <span class="literal">true</span></span><br><span class="line"><span class="built_in">print</span>(dog2.cunstructor === Dog); // <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(dog1 instanceof Dog); // <span class="literal">true</span></span><br><span class="line"><span class="built_in">print</span>(dog2 instanceof Dog); // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">这样看来构造函数模式解决了原始模式的缺点，但是它自己又引入了新的缺点，就是有些时候存在浪费内存的问题。比如说，我们现在要给小狗这个对象添加一个公共的属性“<span class="built_in">type</span>”（种类）和一个公共方法“bark”（吠）：</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Dog(name, variety) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.variety = variety;</span><br><span class="line">    this.type = <span class="string">'犬科'</span>;</span><br><span class="line">    this.bark = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'汪汪汪'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再去实例化对象，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(dog1.bark() === dog2.bark()); // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>从中我们可以看出问题，那就是对于每个实例对象而言，type属性和bark方法都是一样的，但是每次创建新的实例，都要为其分配新的内存空间，这样做就会降低性能，浪费空间，缺乏效率。<br>接下来我们就要思考怎样让这些所有实例对象都相同的内容在内存中只生成一次，并且让所有实例的这些相同内容都指向那个内存地址？</p>
<h5 id="3、Prototype模式"><a href="#3、Prototype模式" class="headerlink" title="3、Prototype模式"></a>3、Prototype模式</h5><p>每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。可以利用这一点，把那些不变的属性和方法，定义在prototype对象上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Dog(name, variety) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.variety = variety;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.type = <span class="string">'犬科'</span>;</span><br><span class="line">Dog.prototype.bark = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'汪汪汪'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var dog1 = new Dog(<span class="string">'二牛'</span>, <span class="string">'牛头梗'</span>);</span><br><span class="line">var dog2 = new Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(dog1.type); // 犬科</span><br><span class="line">dog1.bark(); // 汪汪汪</span><br><span class="line"><span class="built_in">print</span>(dog2.type); // 犬科</span><br><span class="line">dog2.bark(); // 汪汪汪</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(dog1.bark() === dog2.bark()); // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这里所有实例对象的type属性和bark方法，都指向prototype对象，都是同一个内存地址。</p>
<h4 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 现在有一个动物的构造函数：</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Animal</span></span>() &#123;</span><br><span class="line">    this.feeling = <span class="string">'happy'</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 有一个小狗的构造函数：</span><br><span class="line"><span class="keyword">function</span> Dog(name, variety) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.variety = variety;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下如不对Animal和Dog对象进行重写，则使用该代码进行代入，示例代码中不再重复。</p>
<h5 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Dog.prototype = new Animal();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line">var dog = new Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog.feeling); // happy</span><br></pre></td></tr></table></figure>
<p>原型链继承存在两个问题：第一点是当被继承对象中包含引用类型的属性时，该属性会被所有实例对象共享，示例代码如下；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Animal</span></span>() &#123;</span><br><span class="line">    this.colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Dog</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 继承Animal</span><br><span class="line">Dog.prototype = new Animal();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"> </span><br><span class="line">var dog1 = new Dog();</span><br><span class="line">dog1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog1.colors); // red,green,blue,black</span><br><span class="line"> </span><br><span class="line">var dog2 = new Dog();</span><br><span class="line"><span class="built_in">print</span>(dog2.colors); // red,green,blue,black</span><br></pre></td></tr></table></figure>
<p>第二点是不能在不影响所有实例对象的情况下，向父级构造函数传递参数，这一点不做示例，大家可以自行验证下；</p>
<h5 id="2、构造函数继承"><a href="#2、构造函数继承" class="headerlink" title="2、构造函数继承"></a>2、构造函数继承</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Dog(name, variety) &#123;</span><br><span class="line">    Animal.apply(this, arguments);</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.variety = variety;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var dog = new Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog.feeling); // happy</span><br></pre></td></tr></table></figure>
<p>这是一种十分简单的方法，使用apply或者call方法改变构造函数作用域，将父函数的构造函数绑定到子对象上。虽然解决了子对象向父对象传递参数的目的，但是借助构造函数，方法都在构造函数中定义，函数的复用就无从谈起。</p>
<h5 id="3、构造函数和原型链组合继承"><a href="#3、构造函数和原型链组合继承" class="headerlink" title="3、构造函数和原型链组合继承"></a>3、构造函数和原型链组合继承</h5><p>利用构造函数实现对实例属性的继承，使用原型链完成对原型属性和方法的继承，避免了原型链和构造函数的缺陷。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Animal(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.sayName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> Dog(name, age) &#123;</span><br><span class="line">    // 继承属性</span><br><span class="line">    Animal.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">// 继承方法</span><br><span class="line">Dog.prototype = new Animal();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line">Dog.prototype.sayAge = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(this.age);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var dog1 = new Dog(<span class="string">'二狗'</span>, 1);</span><br><span class="line">dog1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog1.colors); // red,green,blue,black</span><br><span class="line">dog1.sayName(); // 二狗</span><br><span class="line">dog1.sayAge(); // 1</span><br><span class="line"> </span><br><span class="line">var dog2 = new Dog(<span class="string">'二牛'</span>, 2);</span><br><span class="line"><span class="built_in">print</span>(dog2.colors); // red,green,blue</span><br><span class="line">dog2.sayName(); // 二牛</span><br><span class="line">dog2.sayAge(); // 2</span><br></pre></td></tr></table></figure>
<h5 id="4、YUI式继承"><a href="#4、YUI式继承" class="headerlink" title="4、YUI式继承"></a>4、YUI式继承</h5><p>由原型链继承延伸而来，避免了实例对象的prototype指向同一个对象的缺点（Dog.prototype包含一内部指针指向Animal.prototype，同时Dog的所有实例也都包含一内部指针指向Dog.prototype，那么任何对Dog实例上继承自Animal的属性或方法的修改，都会反映到Dog.prototype）。让Dog跳过Animal，直接继承Animal.prototype，这样省去执行和创建Animal实例，提高了效率。利用一个空对象作为媒介，空对象几乎不占用内存，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Animal</span></span>() &#123;&#125;</span><br><span class="line">Animal.prototype.feeling = <span class="string">'happy'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> extend(Child, Parent) &#123;</span><br><span class="line">    var F = <span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">    F.prototype = Parent.prototype;</span><br><span class="line">    Child.prototype = new F();</span><br><span class="line">    Child.prototype.constructor = Child;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">extend(Dog, Animal);</span><br><span class="line"> </span><br><span class="line">var dog = new Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog.feeling); // happy</span><br></pre></td></tr></table></figure>
<h5 id="5、拷贝继承（浅拷贝和深拷贝）"><a href="#5、拷贝继承（浅拷贝和深拷贝）" class="headerlink" title="5、拷贝继承（浅拷贝和深拷贝）"></a>5、拷贝继承（浅拷贝和深拷贝）</h5><p>把父对象的属性和方法，全部拷贝给子对象，也能实现继承。</p>
<h6 id="①-浅复制"><a href="#①-浅复制" class="headerlink" title="① 浅复制"></a>① 浅复制</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Animal</span></span>() &#123;&#125;</span><br><span class="line">Animal.prototype.feeling = <span class="string">'happy'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> extend(Child, Parent) &#123;</span><br><span class="line">    var p = Parent.prototype;</span><br><span class="line">    var c = Child.prototype;</span><br><span class="line">    <span class="keyword">for</span> (var i <span class="keyword">in</span> p) &#123;</span><br><span class="line">        c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">extend(Dog, Animal);</span><br><span class="line"> </span><br><span class="line">var dog = new Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog.feeling); // happy</span><br></pre></td></tr></table></figure>
<p>但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能,比如在上例中适当位置添加如下代码会发现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Animal.prototype.colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"> </span><br><span class="line">Dog.colors.push(<span class="string">'black'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(Dog.colors); // red,green,blue,black</span><br><span class="line"><span class="built_in">print</span>(Animal.colors); // red,green,blue,black</span><br></pre></td></tr></table></figure>
<p>当然，这也是jquery早期实现继承的方式。</p>
<h6 id="②-深复制"><a href="#②-深复制" class="headerlink" title="② 深复制"></a>② 深复制</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Animal</span></span>() &#123;&#125;</span><br><span class="line">Animal.prototype.feeling = <span class="string">'happy'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> deepCopy(Child, Parent) &#123;</span><br><span class="line">    var p = Parent.prototype;</span><br><span class="line">    var c = Child.prototype;</span><br><span class="line">    <span class="keyword">for</span> (var i <span class="keyword">in</span> p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof p[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">            c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</span><br><span class="line">            deepCopy(p[i], c[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c[i] = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">deepCopy(Dog, Animal);</span><br><span class="line"> </span><br><span class="line">var dog = new Dog(<span class="string">'二狗'</span>, <span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">print</span>(dog.feeling); // happy</span><br></pre></td></tr></table></figure>
<p>深拷贝，能够实现真正意义上的数组和对象的拷贝。这时，在子对象上修改属性（引用类型），就不会影响到父元素了。这也是目前jquery使用的继承方式</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下mysql入门</title>
    <url>/2017/12/11/mac%E4%B8%8Bmysql%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>之前学过一点时间node，但是断断续续掌握的并不系统，前几个月从上海回到武汉，总算体验了回离家近的感觉，也有时间开始捣鼓一些一直想要做的事情了。</p>
</blockquote>
<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>mac系统下node，很简单就不赘述了，直接百度~</p>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul>
<li>1、<a href="https://share.weiyun.com/658f9a3fe0e7cd6b06ee938969d48576" target="_blank" rel="noopener">MySQL(mac版)</a></li>
<li>2、<a href="https://share.weiyun.com/ab82e4951788e1adec30e6b09aae5309" target="_blank" rel="noopener">Navicat for MySQL(mac破解版)</a></li>
</ul>
<a id="more"></a>
<h4 id="MySQL安装步骤"><a href="#MySQL安装步骤" class="headerlink" title="MySQL安装步骤"></a>MySQL安装步骤</h4><ul>
<li>1、 双击 .dmg 文件，开始安装，一直点击继续，直到最后一步出现如下弹框：</li>
<li>2、 将root账号的初始密码保存，此密码非常重要，切记保存,点击ok，完成安装</li>
<li>3、 进入系统偏好与设置，点击左下角MySQL应用图标，运行服务，并且在启动页面点击“run MySQL Server”按钮。</li>
</ul>
<h4 id="MySQL环境变量配置"><a href="#MySQL环境变量配置" class="headerlink" title="MySQL环境变量配置"></a>MySQL环境变量配置</h4><ul>
<li>1、打开命令行，输入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p>此时会提示“commod not found”，因为此时我们还未将mysql加入系统环境变量；</p>
<ul>
<li>2、ls，查看此目录下是否有mysql</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local/mysql/bin</span><br></pre></td></tr></table></figure>
<ul>
<li>3、命令行输入：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>在该文件中添加mysql/bin的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PATH=$PATH:/u sr/local/mysql/bin</span><br></pre></td></tr></table></figure>
<ul>
<li>4、添加完成后，按esc，接着按大写键（caps lock），再按Q，再切换成小写，输入wq，退出并保存该文件；</li>
<li>5、现在可以登录mysql了，此时会提示输入密码，该密码即刚才反复强调需要保存的密码。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<h4 id="修改MySQL初始密码"><a href="#修改MySQL初始密码" class="headerlink" title="修改MySQL初始密码"></a>修改MySQL初始密码</h4><ul>
<li>1、在系统偏好与设置内，运行MySQL</li>
<li>2、连接server,命令行输入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<ul>
<li>3、输入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE mysql.user SET authentication_string=PASSWORD(&apos;123456&apos;) WHERE User=&apos;root&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li>4、如果出现ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement ；则需要</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set password=password(&apos;123456&apos;);</span><br></pre></td></tr></table></figure>
<p>//此处密码必须跟上面设置的密码一样；  </p>
<ul>
<li>4、输入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<ul>
<li>5、按quit;退出</li>
</ul>
<h4 id="使用图形化工具-Navicat-for-MySQL"><a href="#使用图形化工具-Navicat-for-MySQL" class="headerlink" title="使用图形化工具 Navicat for MySQL"></a>使用图形化工具 Navicat for MySQL</h4><ul>
<li>1、单击下载好的Navicat,按照提示，打开应用</li>
<li>2、新建连接，输入对应配置信息，其中连接名可以随便填写</li>
<li>3、点击连接测试，确定连接成功</li>
</ul>
<h4 id="卸载MySQL"><a href="#卸载MySQL" class="headerlink" title="卸载MySQL"></a>卸载MySQL</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/local/mysql</span><br><span class="line">sudo rm -rf /usr/local/mysql*</span><br><span class="line">sudo rm -rf /Library/StartupItems/MySQLCOM</span><br><span class="line">sudo rm -rf /Library/PreferencePanes/My*</span><br><span class="line">rm -rf ~/Library/PreferencePanes/My*</span><br><span class="line">sudo rm -rf /Library/Receipts/mysql*</span><br><span class="line">sudo rm -rf /Library/Receipts/MySQL*</span><br><span class="line">sudo rm -rf /var/db/receipts/com.mysql.</span><br></pre></td></tr></table></figure>
<p>调用vim /etc/hostconfig，删除 MYSQLCOM=-YES-这一行。</p>
<h4 id="常用命令行操作"><a href="#常用命令行操作" class="headerlink" title="常用命令行操作"></a>常用命令行操作</h4><ul>
<li><p>创建一个名字为mydatabase数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database mydatabase;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看创建的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改数据库名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter databases Hdatabase;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mydatabase;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看该数据库中的表</p>
</li>
</ul>
<pre><code>show tables;
</code></pre><ul>
<li>创建表</li>
</ul>
<pre><code class="bash">create table student (
          name varchar(10) , 
          gender varchar(10) , 
          sno int primary key(id)
         )charset utf8;
</code></pre>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组方法使用小结</title>
    <url>/2017/12/20/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h5 id="1、filter-，“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组"><a href="#1、filter-，“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组" class="headerlink" title="1、filter()，“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组"></a>1、filter()，“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组</h5><ul>
<li>参数：function(item,index,arr)</li>
<li>不会更改原数组</li>
<li>有返回值，返回依条件返回的数组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr1 = [&#123;</span><br><span class="line">	name: <span class="string">'xugang'</span>,</span><br><span class="line">	age: 28</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	name: <span class="string">'wangran'</span>,</span><br><span class="line">	age: 27</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">const arr2 = arr1.filter((item)=&gt;&#123;</span><br><span class="line">	<span class="built_in">return</span> item.name === <span class="string">'xugang'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">arr2   // arr2 = [&#123;name:<span class="string">'xugang'</span>,age:28&#125;]</span><br><span class="line"></span><br><span class="line">以上可以简写为：</span><br><span class="line">const arr2 = arr1.filter(item=&gt;item.name === <span class="string">'xugang'</span>);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="2、map-，指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。"><a href="#2、map-，指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。" class="headerlink" title="2、map()，指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。"></a>2、map()，指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</h5><ul>
<li>参数：function(item,index,arr)</li>
<li>会更改原数组</li>
<li>有返回值，返回新的数组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [&#123;</span><br><span class="line">	animal: <span class="string">'dag'</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">	animal: <span class="string">'cat'</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">arr.map((item,index)=&gt;&#123;</span><br><span class="line">	item.color = <span class="string">'red'</span></span><br><span class="line">&#125;)</span><br><span class="line">arr   // arr = [&#123;animal: <span class="string">'dag'</span>,color: <span class="string">'red'</span>&#125;,&#123;animal: <span class="string">'cat'</span>,color: <span class="string">'red'</span>&#125;]</span><br></pre></td></tr></table></figure>
<h5 id="3、every-，判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。"><a href="#3、every-，判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。" class="headerlink" title="3、every()，判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。"></a>3、every()，判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</h5><ul>
<li>参数：function(item,index,arr)</li>
<li>不会更改原数组</li>
<li>有返回值: true or false</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1, 2, 3, 4, 5];</span><br><span class="line">const status = arr.every((item,index)=&gt;&#123;</span><br><span class="line">	<span class="built_in">return</span> item &lt; 10</span><br><span class="line">&#125;)   </span><br><span class="line">status // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">const status = arr.every((item,index)=&gt;&#123;</span><br><span class="line">	<span class="built_in">return</span> item &gt; 3</span><br><span class="line">&#125;)</span><br><span class="line">status // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h5 id="4、some-，判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。"><a href="#4、some-，判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。" class="headerlink" title="4、some()，判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。"></a>4、some()，判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</h5><ul>
<li>参数：function(item,index,arr)</li>
<li>不会更改原数组</li>
<li>有返回值: true or false</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1, 2, 3, 4, 5];</span><br><span class="line">const status = arr.some((item,index)=&gt;&#123;</span><br><span class="line">	<span class="built_in">return</span> item &lt; 2</span><br><span class="line">&#125;)   </span><br><span class="line">status // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">const status = arr.some((item,index)=&gt;&#123;</span><br><span class="line">	<span class="built_in">return</span> item &lt; 1</span><br><span class="line">&#125;)   </span><br><span class="line">status // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h5 id="4、forEach-，对数组进行遍历循环，对数组中的每一项运行给定函数。"><a href="#4、forEach-，对数组进行遍历循环，对数组中的每一项运行给定函数。" class="headerlink" title="4、forEach()，对数组进行遍历循环，对数组中的每一项运行给定函数。"></a>4、forEach()，对数组进行遍历循环，对数组中的每一项运行给定函数。</h5><ul>
<li>参数：function(item,index,arr)</li>
<li>不会更改原数组</li>
<li>没有返回值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [&#123;</span><br><span class="line">	name: <span class="string">'xugang'</span>,</span><br><span class="line">	age: 28</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	name: <span class="string">'wangran'</span>,</span><br><span class="line">	age: 27</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">let</span> arr1 = [];</span><br><span class="line">arr.forEach((item,index)=&gt;&#123;</span><br><span class="line">	<span class="keyword">if</span>(item.name === <span class="string">'wangran'</span>)&#123;</span><br><span class="line">		arr1.push(item.age)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">arr1   // [27]</span><br></pre></td></tr></table></figure>
<h5 id="5、slice-，返回从原数组中指定开始下标到结束下标之间的项组成的新数组。"><a href="#5、slice-，返回从原数组中指定开始下标到结束下标之间的项组成的新数组。" class="headerlink" title="5、slice()，返回从原数组中指定开始下标到结束下标之间的项组成的新数组。"></a>5、slice()，返回从原数组中指定开始下标到结束下标之间的项组成的新数组。</h5><ul>
<li>参数：接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始（包括指定位置）到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。如果开始下标或者结束下标出现负数，则加上原数组长度，转换为正数。</li>
<li>不会更改原数组</li>
<li>有返回值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1,2,3,4,5,6,7,8]</span><br><span class="line">const arr1 = arr.slice(2)   // [3,4,5,6,7,8]，从起始下标（包含起始下标）开始到数组结束</span><br><span class="line">const arr2 = arr.slice(2,5) // [3,4,5] ，从起始下标（包含起始下标）开始到结束下标（不包含结束下标）</span><br><span class="line">const arr3 = arr.slice(2,-2) // [3,4,5,6]，结束下标为（-2 + 8 = 6）</span><br><span class="line">const arr4 = arr.slice(-3,-2) // [6]，开始下标为（-3 + 8 = 5），结束下标为（-2 + 8 = 6）</span><br></pre></td></tr></table></figure>
<h5 id="6、splice-，很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。"><a href="#6、splice-，很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。" class="headerlink" title="6、splice()，很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。"></a>6、splice()，很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。</h5><ul>
<li>参数：接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始（包括指定位置）到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。如果开始下标或者结束下标出现负数，则加上原数组长度，转换为正数。</li>
<li>会更改原数组</li>
<li>有返回值，始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1,2,3,4,5,6,7,8]</span><br><span class="line">const arr1 = arr.slice(2)   // [3,4,5,6,7,8]，从起始下标（包含起始下标）开始到数组结束</span><br><span class="line">const arr2 = arr.slice(2,5) // [3,4,5] ，从起始下标（包含起始下标）开始到结束下标（不包含结束下标）</span><br><span class="line">const arr3 = arr.slice(2,-2) // [3,4,5,6]，结束下标为（-2 + 8 = 6）</span><br><span class="line">const arr4 = arr.slice(-3,-2) // [6]，开始下标为（-3 + 8 = 5），结束下标为（-2 + 8 = 6）</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>react dva学习心得</title>
    <url>/2017/10/16/react-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>　　前端技术日新月异，三大框架盛行的年代，正是web developer 大展宏图的好时期。选择何种框架，要根据公司实际业务。比如我现在公司是做企业后台，业务逻辑复杂，客户对表格的要求很高，这种情况下，使用react会比较合适，特别是基于react和redux的最佳实践dva框架，体验非常好！但是像之前上海的公司，只涉及微信商城构建，主要难点是订单流，业务不算复杂，这种情况下，使用vue会更加合适。轻量、高效，上手快，是小公司的绝佳选择。
　　
　　</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>setTimeout详解</title>
    <url>/2018/03/12/setTimeout%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>使用hexo + github + Yilia搭建个人博客</title>
    <url>/2017/12/22/%E4%BD%BF%E7%94%A8hexo-github-Yilia%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>大概是在半年前，自己花了大半天的时间摸索，终于搭建好了基于hexo+github的博客，这几天正好有个同事请教我，借此机会写个教程，免得后面遗忘。</p>
<ul>
<li>注*：和其他教程一样，本教程同样只适用于mac用户</li>
</ul>
</blockquote>
<h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><ul>
<li>1、 搭建node环境（省略）</li>
<li>2、 安装git（省略）</li>
<li>3、 确认以上安装成功，命令行分别输入，出现版本号，即表示安装成功</li>
</ul>
<a id="more"></a>
<pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">git -v</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>4、我之前写过<a href="https://suifengcool.github.io/2017/12/13/git-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">git常用命令的小结</a>，大家可以参考下</li>
</ul>
<h3 id="在github上创建pages项目"><a href="#在github上创建pages项目" class="headerlink" title="在github上创建pages项目"></a>在github上创建pages项目</h3><ul>
<li>1、 注册github，登录，此步骤省略</li>
<li>2、 在<a href="https://github.com/" target="_blank" rel="noopener">github官网</a>，点击右上角“+”，选择New repository，进入项目创建页</li>
<li>3、 在”Repository name”输入框内输入“xxx.github.io”，其中“xxx”对应自己的用户名</li>
<li>4、 点击底部按钮“Create repository”，完成创建，跳转至该项目页</li>
<li>5、 点击右上角Settings，跳至设置页，下拉找到GitHub Pages栏，先点击Choose a Theme，然后再点击save按钮。此时，github.io已经可以访问了。</li>
</ul>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><ul>
<li><p>全局安装hexo脚手架</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo -v     // 出现版本号则安装成功，那么hexo安装成功</span><br></pre></td></tr></table></figure>
</li>
<li><p>hexo初始化项目</p>
</li>
</ul>
<pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>本地运行</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s -debug</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>此时，浏览器输入<a href="localhost:4000" target="_blank" rel="noopener">localhost:4000</a>，就可以看到项目运行了。</p>
<h3 id="将hexo和github绑定"><a href="#将hexo和github绑定" class="headerlink" title="将hexo和github绑定"></a>将hexo和github绑定</h3><ul>
<li><p>安装部署工具</p>
<pre><code class="bash">npm install hexo-deployer-git -save
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>JS变量</title>
    <url>/2020/11/22/%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<blockquote>
<p>一步一步重温 <strong>JavaScript</strong> 基础系列。<br>本章节将会理解JS的变量，包括变量的含义、变量的值、复制变量的值，以及传递参数</p>
</blockquote>
<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>JavaScipt变量松散类型的本质，决定了变量只是在特定时间内用于保存特定值的一个名字，或者称之为引用。</p>
<a id="more"></a>
<h2 id="2-变量的值"><a href="#2-变量的值" class="headerlink" title="2 变量的值"></a>2 变量的值</h2><p>分为基本类型变量的值，和引用类型变量的值。其中，基本类型变量的值大小固定，存放于栈内存中，允许直接操作，即基本类型变量是按值访问；而引用数据类型变量的值大小不固定，存放于堆内存中，不可直接访问，其引用地址（即变量）存放于栈内存中，故引用数据类型变量的值是按引用访问。</p>
<h2 id="3-复制变量的值"><a href="#3-复制变量的值" class="headerlink" title="3 复制变量的值"></a>3 复制变量的值</h2><ul>
<li><p><strong>值为基本数据类型的变量</strong>，与复制后形成的变量，相互独立，后续赋值各不相干；</p>
</li>
<li><p><strong>值为引用数据类型的变量</strong>，复制时，实际上是复制一个指针（或称之为引用），共同指向堆内存中的同一对象。当其中一个变量操作该对象的属性时，另外一个变量对应的属性也会随之改变，因为他们指向的是同一个对象。</p>
</li>
</ul>
<p>实例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 值为基本数据类型的变量</span><br><span class="line">var num1 = 5;</span><br><span class="line">var num2 = num1;</span><br><span class="line">num2 ++;</span><br><span class="line"></span><br><span class="line">console.log(num1)  // 5</span><br><span class="line">console.log(num2)  // 6</span><br><span class="line"></span><br><span class="line">// 值为引用数据类型的变量</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">  name: &apos;xugang&apos;,</span><br><span class="line">  age: 30</span><br><span class="line">&#125;</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj2.age = 32</span><br><span class="line"></span><br><span class="line">console.log(obj1.age)  // 32</span><br></pre></td></tr></table></figure></p>
<p>图解如下：</p>
<p><img src="/images/复制变量值.jpg" alt="复制变量的值图解"></p>
<h2 id="4-变量作为参数传递-–-JS中所有函数的参数都是按值传递"><a href="#4-变量作为参数传递-–-JS中所有函数的参数都是按值传递" class="headerlink" title="4 变量作为参数传递 – JS中所有函数的参数都是按值传递"></a>4 变量作为参数传递 – JS中所有函数的参数都是按值传递</h2><p>函数在传递参数时，就是把实参复制给形参，即函数的局部变量。如果实参是引用数据类型，则复制形成的行参和实参相互独立，互不影响；如果是引用数据类型，此时，实参复制的是一份指针，共同指向堆内存中的同一对象，所以此时修改形参的属性或属性值，则会影响对应实参的属性和属性值。</p>
<p><strong>那如何理解函数中参数传递，是按值传递，而不是按引用传递？</strong></p>
<ol>
<li>如果为按值传递，则复制的是一个指针，共同指向堆内存中的同一对象，此时形参属性和属性值的改变，会影响外部实参的属性和属性值；</li>
<li>如果为按引用传递，则意味着传递整个变量，此时如果改变局部变量即形参的引用地址，也会相应改变实参的引用地址，这显然和实际不符。</li>
</ol>
<p><strong>总结如下：</strong><br>所谓变量作为参数传递是按值传递，是指将外部变量（实参）的值复制给内部局部变量（实参），也就是在栈内存中复制出一份指针，共同指向堆内存的同一对象。函数内部可以通过改变形参的属性和属性值来改变，外部变量（实参）对应的属性和属性值， 但是不能操作外部变量（实参）本身。图解如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setName(obj) &#123;</span><br><span class="line">  obj.name = &apos;xugang&apos;;</span><br><span class="line">  </span><br><span class="line">  // 改变局部变量（形参）的引用地址，指向堆内存中的一个新对象</span><br><span class="line">  obj = new Object();</span><br><span class="line">  obj.name = &apos;suifeng&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Object();</span><br><span class="line">setName(person);</span><br><span class="line"></span><br><span class="line">console.log(person) // &#123;name: &apos;xugang&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>图解如下：</p>
<p><img src="/images/按值传递.jpg" alt="按值传递图解"></p>
]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>基于react框架Dva下点击事件及获取点击数据</title>
    <url>/2017/10/19/%E5%9F%BA%E4%BA%8Ereact%E6%A1%86%E6%9E%B6Dva%E4%B8%8B%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%8F%8A%E8%8E%B7%E5%8F%96%E7%82%B9%E5%87%BB%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h5 id="1-有状态的组件"><a href="#1-有状态的组件" class="headerlink" title="1.有状态的组件"></a>1.有状态的组件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bindOff = (e) =&gt; &#123;</span><br><span class="line">	<span class="built_in">let</span> Token = cookie.load(<span class="string">'userdata'</span>);</span><br><span class="line">	message.info(<span class="string">'解绑成功！'</span>)</span><br><span class="line">	_EquipmentIndex.props.dispatch(&#123;</span><br><span class="line">		<span class="built_in">type</span>: <span class="string">'Equipment/BindRoute'</span>,</span><br><span class="line">		payload: &#123;</span><br><span class="line">			companyId:Token.companyId,</span><br><span class="line">			deviceId:e</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">&lt;a onClick=&#123;()=&gt;this.bindOff(record)&#125;&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="2-无状态的组件"><a href="#2-无状态的组件" class="headerlink" title="2.无状态的组件"></a>2.无状态的组件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">handleSubmite(e) &#123;</span><br><span class="line">	console.log(<span class="string">'点击事件'</span>)</span><br><span class="line">&#125;	</span><br><span class="line">&lt;Button onClick=&#123;handleSubmit(e)&#125;&gt;点击&lt;/Button&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>解决使用axios后POST请求会出现OPTIONS预请求问题</title>
    <url>/2018/03/27/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8axios%E5%90%8EPOST%E8%AF%B7%E6%B1%82%E4%BC%9A%E5%87%BA%E7%8E%B0OPTIONS%E9%A2%84%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>Vue 的作者尤雨溪几个月前发表了一篇博客，表示 vue-resource 将不再是官方推荐的库，建议大家以 axios 替代。由此，开始了使用 axios 的历程，但是实践发现每次POST请求，都会先发送一个OPTIONS的请求，然后再发送正常的POST请求。</p>
</blockquote>
<a id="more"></a>
<p>查了一些资料，发现这个问题，其实并不复杂。<br>　　<br>跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。 </p>
<p>也就是说，它会先使用options去测试，你这个接口是否能够正常通讯，如果不能就不会发送真正的请求过来，如果测试通讯正常，则开始正常请求。 </p>
<p>关于这个问题，需要在后台接口进行设置，允许options请求，不然你的请求就会受到影响。如果请求方式为options，告诉它可以通讯，其他直接什么都不做。</p>
<p><strong>那么问题来了，怎么避免额外发送options请求的问题？</strong><br>　　<br>1、Vue 使用，只需要把格式为json的参数用qs插件转换一下就好了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 第一步：安装qs</span><br><span class="line">npm install qs</span><br><span class="line"></span><br><span class="line">// 第二步：main.js</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">import qs from &apos;qs&apos;</span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios</span><br><span class="line">Vue.prototype.$qs = qs</span><br><span class="line"></span><br><span class="line">// 第三步：（页面调用）</span><br><span class="line">this.$http(&#123;</span><br><span class="line">    method: &apos;post&apos;,</span><br><span class="line">    url: &apos;http://localhost:3000/user/login&apos;,</span><br><span class="line">        data: this.$qs.stringify(&#123;</span><br><span class="line">            account: &apos;xugang&apos;,</span><br><span class="line">            passwd: &apos;123456&apos;,</span><br><span class="line">            email: &apos;371801080@qq.com&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(function (response) &#123;</span><br><span class="line">        console.log(response);</span><br><span class="line">    &#125;).catch(function (error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
</search>
